<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>新的开始</title>
    <link href="/2021/03/02/newstart/"/>
    <url>/2021/03/02/newstart/</url>
    
    <content type="html"><![CDATA[<p>新的开始.</p><p>新学期终于到来啦.</p><a id="more"></a><p>可能我已经习惯新的电脑了,重新打开旧的电脑时,有一种熟悉的陌生感.</p><p>回忆大学打acm的时期,可能是我自己不够勇敢,也不够努力吧.</p><p>研究生阶段也确实获得了很多辩论赛的资源,翻过了之前以为永远都翻不过的山丘,却遇到相同的风景哦,不要太沉迷某一个游戏哦.</p><p>新的学期,新的开始.</p><p>许下新的愿望,希望都可以实现 : )</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵树定理</title>
    <link href="/2020/10/14/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    <url>/2020/10/14/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>惊鸿一瞥 .</p><a id="more"></a><h2 id="double版本"><a href="#double版本" class="headerlink" title="double版本"></a>double版本</h2><p>这个是oi wiki上的原原本本的代码,我直接照抄了 .</p><p>参考资料:<br>    <a href="https://oi-wiki.org/math/gauss/" target="_blank" rel="noopener">https://oi-wiki.org/math/gauss/</a><br>    <a href="https://oi-wiki.org/graph/matrix-tree/" target="_blank" rel="noopener">https://oi-wiki.org/graph/matrix-tree/</a> </p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// https://oi-wiki.org/math/gauss/ </span><span class="hljs-comment">// https://oi-wiki.org/graph/matrix-tree/ </span><span class="hljs-comment">// 本篇中的图，无论无向还是有向，都允许重边，但是不允许自环。</span><span class="hljs-comment">// double 版本</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 100000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-7</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matrix</span> &#123;</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">20</span>;  <span class="hljs-keyword">int</span> n, m;  <span class="hljs-keyword">double</span> mat[maxn][maxn];  matrix() &#123; <span class="hljs-built_in">memset</span>(mat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mat)); &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"MATRIX "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; m &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; mat[i][j] &lt;&lt; <span class="hljs-string">"\t"</span>;      &#125;      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;n = n;    <span class="hljs-keyword">this</span>-&gt;m = n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) mat[i][j] = rand() % <span class="hljs-number">100</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initSquare</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-number">4</span>;    <span class="hljs-keyword">this</span>-&gt;m = <span class="hljs-number">4</span>;    <span class="hljs-built_in">memset</span>(mat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mat));    mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = mat[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;    mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = mat[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    mat[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = mat[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;    mat[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = mat[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = mat[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">-2</span>;    <span class="hljs-keyword">this</span>-&gt;n--;  <span class="hljs-comment">// 去一行</span>    <span class="hljs-keyword">this</span>-&gt;m--;  <span class="hljs-comment">// 去一列</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">double</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-keyword">int</span> sid = <span class="hljs-number">-1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++)        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(mat[j][i]) &gt; eps) &#123;          sid = j;          <span class="hljs-keyword">break</span>;        &#125;      <span class="hljs-keyword">if</span> (sid == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;      <span class="hljs-keyword">if</span> (sid != i) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;          swap(mat[sid][j], mat[i][j]);          ans = -ans;        &#125;      &#125;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;        <span class="hljs-keyword">double</span> ratio = mat[j][i] / mat[i][i];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;          mat[j][k] -= mat[i][k] * ratio;        &#125;      &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) ans *= mat[i][i];    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(ans);  &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  srand(<span class="hljs-number">1</span>);  matrix T;  <span class="hljs-comment">// T.random(2);</span>  T.initSquare();  T.<span class="hljs-built_in">print</span>();  <span class="hljs-keyword">double</span> ans = T.gauss();  T.<span class="hljs-built_in">print</span>();  <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre></div><h2 id="mod版本"><a href="#mod版本" class="headerlink" title="mod版本"></a>mod版本</h2><p>题目链接 : <a href="https://www.luogu.com.cn/problem/P4111" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4111</a></p><p>这一份是根据之前hdu6836通过的代码改编的.</p><p>具体的约束条件参考double版本的代码,应该也是<code>本篇中的图，无论无向还是有向，都允许重边，但是不允许自环。</code></p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL ll</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">110</span>;<span class="hljs-keyword">const</span> LL mod= <span class="hljs-number">1e9</span>;<span class="hljs-keyword">const</span> ll MOD=mod;<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;ll res=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) res=res*a%mod;a=a*a%mod;n&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a)</span></span>&#123;<span class="hljs-keyword">return</span> ksm(a,mod<span class="hljs-number">-2</span>);&#125;LL K[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;K[x][y]--;K[y][x]--;K[x][x]++;K[y][y]++;&#125;<span class="hljs-function">LL <span class="hljs-title">gauss</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;LL res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n<span class="hljs-number">-1</span>;j++)&#123;<span class="hljs-keyword">while</span>(K[j][i])&#123;<span class="hljs-keyword">int</span> t=K[i][i]/K[j][i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=n<span class="hljs-number">-1</span>;k++)K[i][k]=(K[i][k]-t*K[j][k]+MOD)%MOD;swap(K[i],K[j]);res=-res;&#125;&#125;res=(res*K[i][i])%MOD;&#125;<span class="hljs-keyword">return</span> (res+MOD)%MOD;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">char</span> pic[maxv][maxv];<span class="hljs-keyword">int</span> id[maxv][maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;<span class="hljs-comment">// 如果tle 可以考虑把memset改成for循环</span><span class="hljs-comment">// 或者 直接单组数据 :-) </span><span class="hljs-built_in">memset</span>(K,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> K);<span class="hljs-built_in">memset</span>(id,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> id);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,pic[i]+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(pic[i][j]==<span class="hljs-string">'.'</span>) id[i][j]=++pos;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m)  <span class="hljs-keyword">if</span>(pic[i][j]==<span class="hljs-string">'.'</span>) &#123;<span class="hljs-keyword">if</span>(id[i<span class="hljs-number">-1</span>][j]) add(id[i][j],id[i<span class="hljs-number">-1</span>][j]);<span class="hljs-keyword">if</span>(id[i][j<span class="hljs-number">-1</span>]) add(id[i][j],id[i][j<span class="hljs-number">-1</span>]);&#125;<span class="hljs-built_in">cout</span>&lt;&lt;gauss(pos)&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="hdu6836"><a href="#hdu6836" class="headerlink" title="hdu6836"></a>hdu6836</h2><p>是hdu多校某场的一个题, 和队友商讨确定主体思路后,自己参考网上矩阵树定理模板,编写了代码.</p><p>有时间记得在补区域赛题和学习知识点的空余时间补一下之前牛客和多校的题目啊 : - )</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// 场上通过的代码</span><span class="hljs-comment">// 之后又提交了一下 </span><span class="hljs-comment">// 336974672020-08-07 09:57:15Accepted6836312MS5180K1565 BG++mainland</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL ll</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">110</span>;<span class="hljs-keyword">const</span> LL mod= <span class="hljs-number">998244353</span>;<span class="hljs-keyword">const</span> ll MOD=mod;<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;ll res=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) res=res*a%mod;a=a*a%mod;n&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a)</span></span>&#123;<span class="hljs-keyword">return</span> ksm(a,mod<span class="hljs-number">-2</span>);&#125;LL K[<span class="hljs-number">40</span>][N][N];<span class="hljs-function">LL <span class="hljs-title">gauss</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> n)</span></span>&#123;LL res=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n<span class="hljs-number">-1</span>;j++)&#123;<span class="hljs-keyword">while</span>(K[p][j][i])&#123;<span class="hljs-keyword">int</span> t=K[p][i][i]/K[p][j][i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=n<span class="hljs-number">-1</span>;k++)K[p][i][k]=(K[p][i][k]-t*K[p][j][k]+MOD)%MOD;swap(K[p][i],K[p][j]);res=-res;&#125;&#125;res=(res*K[p][i][i])%MOD;&#125;<span class="hljs-keyword">return</span> (res+MOD)%MOD;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T,n,m;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-built_in">memset</span>(K,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> K);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-keyword">int</span> x,y;ll w;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;w);K[<span class="hljs-number">32</span>][x][y]--;K[<span class="hljs-number">32</span>][y][x]--;K[<span class="hljs-number">32</span>][x][x]++;K[<span class="hljs-number">32</span>][y][y]++;<span class="hljs-keyword">for</span>(ll p= <span class="hljs-number">0</span>;p&lt;=<span class="hljs-number">30</span>;p++)&#123;<span class="hljs-keyword">if</span>((<span class="hljs-number">1L</span>L&lt;&lt;p)&amp;w)&#123;K[p][x][y]--;K[p][y][x]--;K[p][x][x]++;K[p][y][y]++;&#125;&#125;&#125;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll p=<span class="hljs-number">0</span>;p&lt;=<span class="hljs-number">30</span>;++p)&#123;<span class="hljs-comment">//cout&lt;&lt;p&lt;&lt;" "&lt;&lt;gauss(p,n)&lt;&lt;endl;</span>ans=(ans+gauss(p,n)*(<span class="hljs-number">1L</span>L&lt;&lt;p)%mod)%mod;&#125;ll Mu=gauss(<span class="hljs-number">32</span>,n)%mod;ans=ans*inv(Mu)%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    
    <tags>
      
      <tag>模板留存</tag>
      
      <tag>高斯消元</tag>
      
      <tag>矩阵树定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悬线法</title>
    <link href="/2020/10/07/%E6%82%AC%E7%BA%BF%E6%B3%95/"/>
    <url>/2020/10/07/%E6%82%AC%E7%BA%BF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>悬线法可以理解为是一种dp .</p><a id="more"></a><h2 id="资料介绍"><a href="#资料介绍" class="headerlink" title="资料介绍"></a>资料介绍</h2><p><a href="https://wenku.baidu.com/view/cd82b3f5e87101f69f3195bc.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/cd82b3f5e87101f69f3195bc.html</a></p><p>上述资料其实介绍了两种算法.</p><p>算法1适用于 点数较小时.</p><p>算法2适用于$ n*m$ 较小时,算法2更普遍的被叫做 悬线法.</p><p>上述两种算法各有各自的适用范围.</p><h2 id="zjoi2007-棋盘制作"><a href="#zjoi2007-棋盘制作" class="headerlink" title="zjoi2007 棋盘制作"></a>zjoi2007 棋盘制作</h2><p>题目链接: <a href="https://www.luogu.com.cn/problem/P1169" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1169</a><br>参考资料: <a href="https://zhuanlan.zhihu.com/p/46382722" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46382722</a></p><h3 id="使用-悬线法-算法2-的ac代码"><a href="#使用-悬线法-算法2-的ac代码" class="headerlink" title="使用 悬线法(算法2) 的ac代码"></a>使用 悬线法(算法2) 的ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">4e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m,ans1,ans2;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l left</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r right</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> h height</span><span class="hljs-keyword">int</span> res[maxv][maxv];<span class="hljs-keyword">int</span> l[maxv][maxv];<span class="hljs-keyword">int</span> r[maxv][maxv];<span class="hljs-keyword">int</span> h[maxv][maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;res[i][j]);l[i][j]=r[i][j]=j;h[i][j]=<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// h[i][j] 表示点(i,j)对应的悬线的长度</span><span class="hljs-comment">// l[i][j] 表示点(i,j)对应的悬线向左能够移动到的位置</span><span class="hljs-comment">// r[i][j] 表示点(i,j)对应的悬线向右能够移动到的位置</span>inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">2</span>,m) <span class="hljs-keyword">if</span>(res[i][j]!=res[i][j<span class="hljs-number">-1</span>]) left[i][j]=left[i][j<span class="hljs-number">-1</span>];inc(i,<span class="hljs-number">1</span>,n) dec(j,m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(res[i][j]!=res[i][j+<span class="hljs-number">1</span>]) right[i][j]=right[i][j+<span class="hljs-number">1</span>];inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span> &amp;&amp; res[i][j]!=res[i<span class="hljs-number">-1</span>][j]) &#123;left[i][j]=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(left[i][j],left[i<span class="hljs-number">-1</span>][j]);right[i][j]=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>(right[i][j],right[i<span class="hljs-number">-1</span>][j]);<span class="hljs-built_in">height</span>[i][j]=<span class="hljs-built_in">height</span>[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> a=right[i][j]-left[i][j]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>(a,<span class="hljs-built_in">height</span>[i][j]);ans1=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(ans1,b*b);ans2=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(ans2,a*<span class="hljs-built_in">height</span>[i][j]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n%d\n"</span>,ans1,ans2);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="使用单调栈的ac代码"><a href="#使用单调栈的ac代码" class="headerlink" title="使用单调栈的ac代码"></a>使用单调栈的ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-comment">// 利用单调栈通过了该题目</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">2e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-keyword">int</span> st[maxv];<span class="hljs-keyword">int</span> s,t;<span class="hljs-keyword">int</span> l[maxv],r[maxv];<span class="hljs-keyword">int</span> a[maxv][maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);<span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) a[i][j]^=<span class="hljs-number">1</span>;&#125;inc(i,<span class="hljs-number">1</span>,m) val[i]=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ans1=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ans2=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>) val[j]++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">1</span>) val[j]=<span class="hljs-number">0</span>;s=t=<span class="hljs-number">0</span>;inc(k,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> now = val[k];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) l[k]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> l[k]=st[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[t++]=k;&#125;s=t=<span class="hljs-number">0</span>;dec(k,m,<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> now = val[k];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) r[k]=m;<span class="hljs-keyword">else</span> r[k]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=k;&#125;inc(k,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> a=r[k]-l[k]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=val[k];<span class="hljs-keyword">int</span> c=<span class="hljs-built_in">min</span>(a,b);ans1=<span class="hljs-built_in">max</span>(ans1,c*c);ans2=<span class="hljs-built_in">max</span>(ans2,a*b);&#125;&#125;inc(i,<span class="hljs-number">1</span>,m) val[i]=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">1</span>) val[j]++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>) val[j]=<span class="hljs-number">0</span>;s=t=<span class="hljs-number">0</span>;inc(k,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> now = val[k];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) l[k]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> l[k]=st[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[t++]=k;&#125;s=t=<span class="hljs-number">0</span>;dec(k,m,<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> now = val[k];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) r[k]=m;<span class="hljs-keyword">else</span> r[k]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=k;&#125;inc(k,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> a=r[k]-l[k]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=val[k];<span class="hljs-keyword">int</span> c=<span class="hljs-built_in">min</span>(a,b);ans1=<span class="hljs-built_in">max</span>(ans1,c*c);ans2=<span class="hljs-built_in">max</span>(ans2,a*b);&#125;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;ans1&lt;&lt;<span class="hljs-string">"\n"</span>&lt;&lt;ans2&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="USACO5-3-巨大的牛棚"><a href="#USACO5-3-巨大的牛棚" class="headerlink" title="[USACO5.3]巨大的牛棚"></a>[USACO5.3]巨大的牛棚</h2><p>题目链接  <a href="https://www.luogu.com.cn/problem/P2701" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2701</a></p><p>参考资料  <a href="https://www.cnblogs.com/liweihang/p/13489910.html" target="_blank" rel="noopener">https://www.cnblogs.com/liweihang/p/13489910.html</a></p><p>其实转化一下就是01矩阵中求全0的正方形矩阵最大的边长.</p><h3 id="悬线法ac的代码"><a href="#悬线法ac的代码" class="headerlink" title="悬线法ac的代码"></a>悬线法ac的代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//ac</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">int</span> n,t;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv];<span class="hljs-keyword">int</span> l[maxv][maxv];<span class="hljs-keyword">int</span> r[maxv][maxv];<span class="hljs-keyword">int</span> h[maxv][maxv];<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;t))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,n) a[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-keyword">int</span> tx,ty;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;tx,&amp;ty);a[tx][ty]=<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">inc(i,1,n)&#123;</span><span class="hljs-comment">inc(j,1,n) printf("%4d",a[i][j]);</span><span class="hljs-comment">printf("\n");</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span>inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,n)&#123;l[i][j]=r[i][j]=j;h[i][j]=<span class="hljs-number">1</span>;&#125;ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">2</span>,n) <span class="hljs-keyword">if</span>(a[i][j<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span> &amp;&amp; a[i][j]==<span class="hljs-number">0</span>)l[i][j]=l[i][j<span class="hljs-number">-1</span>];inc(i,<span class="hljs-number">1</span>,n) dec(j,n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span> &amp;&amp; a[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)r[i][j]=r[i][j+<span class="hljs-number">1</span>];inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span> &amp;&amp; a[i][j]==<span class="hljs-number">0</span> &amp;&amp; a[i<span class="hljs-number">-1</span>][j]==<span class="hljs-number">0</span>)&#123;l[i][j]=<span class="hljs-built_in">max</span>(l[i][j],l[i<span class="hljs-number">-1</span>][j]);r[i][j]=<span class="hljs-built_in">min</span>(r[i][j],r[i<span class="hljs-number">-1</span>][j]);h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> aa=r[i][j]-l[i][j]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> bb=h[i][j];<span class="hljs-keyword">int</span> c=<span class="hljs-built_in">min</span>(aa,bb);ans=<span class="hljs-built_in">max</span>(ans,c);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="单调栈ac的代码"><a href="#单调栈ac的代码" class="headerlink" title="单调栈ac的代码"></a>单调栈ac的代码</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// queue</span><span class="hljs-comment">// ac</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">int</span> n,m,T;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv];<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-keyword">int</span> st[maxv];<span class="hljs-keyword">int</span> l[maxv],r[maxv];<span class="hljs-keyword">int</span> ans;<span class="hljs-keyword">int</span> s,t;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;T))&#123;m=n;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) a[i][j]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-keyword">int</span> tx,ty;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;tx,&amp;ty);a[tx][ty]=<span class="hljs-number">1</span>;&#125;ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,m) val[i]=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>) val[j]++;<span class="hljs-keyword">else</span> val[j]=<span class="hljs-number">0</span>;s=t=<span class="hljs-number">0</span>;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;= val[j]) t--;<span class="hljs-keyword">if</span>(s==t) l[j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> l[j]=st[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[t++]=j;&#125;s=t=<span class="hljs-number">0</span>;dec(j,m,<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;= val[j]) t--;<span class="hljs-keyword">if</span>(s==t) r[j]=m;<span class="hljs-keyword">else</span> r[j]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=j;&#125;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> alpha=r[j]-l[j]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> beta=val[j];ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">min</span>(alpha,beta));&#125;<span class="hljs-comment">//inc(j,1,m) printf("%4d",l[j]);cout&lt;&lt;endl;</span><span class="hljs-comment">//inc(j,1,m) printf("%4d",r[j]);cout&lt;&lt;endl;</span>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="奶牛浴场"><a href="#奶牛浴场" class="headerlink" title="奶牛浴场"></a>奶牛浴场</h2><p>题目链接  <a href="https://www.luogu.com.cn/problem/P1578" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1578</a></p><p>参考资料  <a href="https://www.pianshen.com/article/1245215508/" target="_blank" rel="noopener">https://www.pianshen.com/article/1245215508/</a></p><p>这个题目是因为 $ n$和 $m $ 较大,所以使用了<strong>算法1</strong>,时间复杂度是o($s^2$)</p><p>在具体处理时,有一些特殊情况的处理,具体细节见代码 : - 0</p><h3 id="ac代码"><a href="#ac代码" class="headerlink" title="ac代码"></a>ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> node point </span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span>&#123;</span> ll x,y; <span class="hljs-built_in">point</span>(ll x=<span class="hljs-number">0</span>,ll y=<span class="hljs-number">0</span>):x(x),y(y)&#123;&#125;&#125;a[<span class="hljs-number">5010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ll L,W;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;L,&amp;W);<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);a[++n]=<span class="hljs-built_in">point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);a[++n]=<span class="hljs-built_in">point</span>(<span class="hljs-number">0</span>,W);a[++n]=<span class="hljs-built_in">point</span>(L,<span class="hljs-number">0</span>);a[++n]=<span class="hljs-built_in">point</span>(L,W);sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,[](<span class="hljs-keyword">const</span> node &amp; a, <span class="hljs-keyword">const</span> node &amp; b)&#123;<span class="hljs-keyword">return</span> (a.x==b.x)? a.y&lt;b.y: a.x&lt;b.x;&#125;);ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;ll l=<span class="hljs-number">0</span>,h=W,v=L-a[i].x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-keyword">if</span>(a[j].y&lt;=h &amp;&amp; a[j].y&gt;=l || a[j].x==L)&#123;<span class="hljs-keyword">if</span>(v*(h-l)&lt;=ans) <span class="hljs-keyword">break</span>;ans=<span class="hljs-built_in">max</span>(ans,(h-l)*(a[j].x-a[i].x));<span class="hljs-keyword">if</span>(a[j].y==a[i].y) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(a[j].y&gt;a[i].y) h=<span class="hljs-built_in">min</span>(h,a[j].y);<span class="hljs-keyword">else</span> l=<span class="hljs-built_in">max</span>(l,a[j].y);&#125;&#125;l=<span class="hljs-number">0</span>,h=W,v=a[i].x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<span class="hljs-keyword">if</span>((a[j].y&lt;=h &amp;&amp; a[j].y&gt;=l) || a[j].x==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(v*(h-l)&lt;=ans)  <span class="hljs-keyword">break</span>;ans=<span class="hljs-built_in">max</span>(ans,(h-l)*(a[i].x-a[j].x));<span class="hljs-keyword">if</span>(a[j].y==a[i].y) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(a[j].y&gt;a[i].y) h=<span class="hljs-built_in">min</span>(h,a[j].y);<span class="hljs-keyword">else</span> l=<span class="hljs-built_in">max</span>(l,a[j].y);&#125;&#125;&#125;sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,[](node &amp;a,node &amp;b)&#123;<span class="hljs-keyword">return</span> a.y&lt;b.y;&#125;);inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)ans=<span class="hljs-built_in">max</span>(ans,(a[i+<span class="hljs-number">1</span>].y-a[i].y)*L);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>单调栈</tag>
      
      <tag>悬线法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019银川区域赛</title>
    <link href="/2020/10/07/2019%E9%93%B6%E5%B7%9D%E5%8C%BA%E5%9F%9F%E8%B5%9B/"/>
    <url>/2020/10/07/2019%E9%93%B6%E5%B7%9D%E5%8C%BA%E5%9F%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>2019年银川区域赛.</p><p>昨日重现.</p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.jisuanke.com/contest/5527/challenges" target="_blank" rel="noopener">https://www.jisuanke.com/contest/5527/challenges</a></p><h2 id="N-Fibonacci-Sequence"><a href="#N-Fibonacci-Sequence" class="headerlink" title="N Fibonacci Sequence"></a>N Fibonacci Sequence</h2><p>直接输出斐波那契数列的前五项,</p><p>超级超级超级签到的大水题.</p><p>因为难度太低甚至计蒜客都没有收录这个题.</p><h2 id="B-So-Easy"><a href="#B-So-Easy" class="headerlink" title="B So Easy"></a>B So Easy</h2><h3 id="ac代码"><a href="#ac代码" class="headerlink" title="ac代码"></a>ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv];<span class="hljs-keyword">int</span> tx,ty;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">-1</span>) tx=i,ty=j,a[i][j]=<span class="hljs-number">0</span>;&#125;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">int</span> Min=<span class="hljs-number">0x3f3f3f3f</span>;inc(j,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">if</span>(i==tx &amp;&amp; j==ty) <span class="hljs-keyword">continue</span>;   Min=<span class="hljs-built_in">min</span>(Min,a[i][j]);&#125;inc(j,<span class="hljs-number">1</span>,n) a[i][j]-=Min;&#125;inc(j,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">int</span> Min=<span class="hljs-number">0x3f3f3f3f</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(i==tx &amp;&amp; j==ty) <span class="hljs-keyword">continue</span>;Min=<span class="hljs-built_in">min</span>(Min,a[i][j]);&#125;inc(i,<span class="hljs-number">1</span>,n) a[i][j]-=Min;&#125;<span class="hljs-keyword">int</span> ans=-a[tx][ty];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="I-Base62"><a href="#I-Base62" class="headerlink" title="I Base62"></a>I Base62</h2><p>进制转化, 如果是c++的话需要使用大整数模板,当时现场赛抄写模板还抄错了细节,查了很长时间.</p><p>当时python用的并不是很熟练 <del>现在其实也是:-|</del></p><p>下面放出python版的代码,有时间可以写写java版的代码.</p><p>有一个小的坑点,我以注释的形式在代码中标注了:-)</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char_to_num</span><span class="hljs-params">(ch)</span>:</span>    <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-string">'0'</span><span class="hljs-keyword">and</span> ch&lt;=<span class="hljs-string">'9'</span>):        <span class="hljs-keyword">return</span> ord(ch)-ord(<span class="hljs-string">'0'</span>)    <span class="hljs-keyword">elif</span>(ch&gt;=<span class="hljs-string">'A'</span> <span class="hljs-keyword">and</span> ch&lt;=<span class="hljs-string">'Z'</span>):        <span class="hljs-keyword">return</span> ord(ch)-ord(<span class="hljs-string">'A'</span>)+<span class="hljs-number">10</span>    <span class="hljs-keyword">elif</span>(ch&gt;=<span class="hljs-string">'a'</span> <span class="hljs-keyword">and</span> ch&lt;=<span class="hljs-string">'z'</span>):        <span class="hljs-keyword">return</span> ord(ch)-ord(<span class="hljs-string">'a'</span>)+<span class="hljs-number">36</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_to_char</span><span class="hljs-params">(num)</span>:</span>    <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num&lt;=<span class="hljs-number">9</span>):        <span class="hljs-keyword">return</span> chr(num+ord(<span class="hljs-string">'0'</span>))    <span class="hljs-keyword">elif</span>(num&gt;=<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> num&lt;=<span class="hljs-number">35</span>):        <span class="hljs-keyword">return</span> chr(num<span class="hljs-number">-10</span>+ord(<span class="hljs-string">'A'</span>))    <span class="hljs-keyword">elif</span>(num&gt;=<span class="hljs-number">36</span> <span class="hljs-keyword">and</span> num&lt;=<span class="hljs-number">61</span>):        <span class="hljs-keyword">return</span> chr(num<span class="hljs-number">-36</span>+ord(<span class="hljs-string">'a'</span>))    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>o=input().split()x=int(o[<span class="hljs-number">0</span>])y=int(o[<span class="hljs-number">1</span>])z=o[<span class="hljs-number">2</span>]a=<span class="hljs-number">0</span><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> z:    val=char_to_num(ch)    a=a*x+valans=<span class="hljs-string">''</span><span class="hljs-keyword">while</span>(a!=<span class="hljs-number">0</span>):    t=a//y    val=a-t*y    a=t    ch=num_to_char(val)    ans+=ch<span class="hljs-string">'''</span><span class="hljs-string">如果a=0 那么上面while的过程是不会走的</span><span class="hljs-string">'''</span><span class="hljs-keyword">if</span>(len(ans)==<span class="hljs-number">0</span>):    ans+=<span class="hljs-string">'0'</span>res=<span class="hljs-string">''</span><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> ans:    res=ch+resprint(res)</code></pre></div><h2 id="G-Pot"><a href="#G-Pot" class="headerlink" title="G Pot!!!"></a>G Pot!!!</h2><p>看懂题意之后,就会明白这是一个 需要区间加和区间求最大的线段树 的数据结构题.</p><p>数据结构的细节可能会比较繁琐,耐心一点哦:-)</p><h3 id="ac代码-1"><a href="#ac代码-1" class="headerlink" title="ac代码"></a>ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> l,r;<span class="hljs-keyword">int</span> mx;<span class="hljs-keyword">int</span> add;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(x) tree[x].l</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(x) tree[x].r</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mx(x) tree[x].mx</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> add(x) tree[x].add</span>&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>][<span class="hljs-number">5</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> p)</span></span>&#123;tree[o][p].mx=<span class="hljs-built_in">max</span>(tree[ls][p].mx,tree[rs][p].mx);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> p)</span></span>&#123;tree[o][p].l=l;tree[o][p].r=r;tree[o][p].mx=<span class="hljs-number">0</span>,tree[o][p].add=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(l,m,ls,p);build(m+<span class="hljs-number">1</span>,r,rs,p);pushup(o,p);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o][p].add!=<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">int</span> l=tree[o][p].l;<span class="hljs-keyword">int</span> r=tree[o][p].r;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;tree[ls][p].mx+=tree[o][p].add;tree[rs][p].mx+=tree[o][p].add;tree[ls][p].add+=tree[o][p].add;tree[rs][p].add+=tree[o][p].add;tree[o][p].add=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> add,<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o][p].l,r=tree[o][p].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tree[o][p].add+=add;tree[o][p].mx+=add;<span class="hljs-keyword">return</span> ;&#125;pushdown(o,p);<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,add,ls,p);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,add,rs,p);pushup(o,p);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o][p].l,r=tree[o][p].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> tree[o][p].mx;pushdown(o,p);<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> res=<span class="hljs-number">-0x3f3f3f3f</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) res=<span class="hljs-built_in">max</span>(res,query(ql,qr,ls,p));<span class="hljs-keyword">if</span>(m&lt;qr) res=<span class="hljs-built_in">max</span>(res,query(ql,qr,rs,p));<span class="hljs-keyword">return</span>  res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">char</span> s[<span class="hljs-number">20</span>];<span class="hljs-keyword">bool</span> show=<span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;show=<span class="hljs-literal">false</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q);inc(i,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,i);<span class="hljs-keyword">while</span>(q--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);<span class="hljs-keyword">if</span>(show)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,s);<span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>]==<span class="hljs-string">'U'</span>)&#123;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);<span class="hljs-keyword">if</span>(show) <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;c&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">if</span>(c==<span class="hljs-number">2</span>) &#123;update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">3</span>) update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">4</span>) update(a,b,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">5</span>) update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">6</span>)&#123;update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">7</span>)&#123;update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">8</span>)&#123;update(a,b,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">9</span>)&#123;update(a,b,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">10</span>)&#123;update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);update(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> a,b;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);<span class="hljs-keyword">if</span>(show)<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">int</span> t=query(a,b,<span class="hljs-number">1</span>,i);res=<span class="hljs-built_in">max</span>(res,t);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"ANSWER %d\n"</span>,res);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="F-function"><a href="#F-function" class="headerlink" title="F function!"></a>F function!</h2><p>前缀和的前缀和,是一个数学题,感觉还挺技巧的,</p><p>如果范围大的话可以直接利用公式推导,如果范围小的话直接分块了.</p><p>还是这种类型的题目做的不够多啊.</p><p>为了处理mod 过程中可能出现的各种问题,我写了一个支持+,-,*时候同时进行mod运算的类,可以加入模板组.</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>具体的数学推导可以看下面这个博客</p><p><a href="https://blog.csdn.net/weixin_43464149/article/details/103326814" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43464149/article/details/103326814</a></p><p>一个很好看的分数类的代码,利用的是friend函数,不过这个代码可能不适合在acm场上写,太繁琐了</p><p><a href="https://www.cnblogs.com/gongkai/p/10806080.html" target="_blank" rel="noopener">https://www.cnblogs.com/gongkai/p/10806080.html</a></p><h3 id="ac代码-2"><a href="#ac代码-2" class="headerlink" title="ac代码"></a>ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> ll mod = <span class="hljs-number">998244353</span>; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mint</span>&#123;</span>ll val;mint(ll o=<span class="hljs-number">0</span>)&#123;val=o;&#125;<span class="hljs-function">ll <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> val;&#125;mint <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> mint &amp; rhs) <span class="hljs-keyword">const</span>&#123;ll u=val%mod;ll v=rhs.val%mod;mint res;res.val=(u+v)%mod;<span class="hljs-keyword">return</span> res;&#125;mint <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> mint &amp; rhs) <span class="hljs-keyword">const</span>&#123;ll u=val%mod;ll v=rhs.val%mod;mint res;res.val=(u-v+mod)%mod;<span class="hljs-keyword">return</span> res;&#125;mint <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mint &amp; rhs) <span class="hljs-keyword">const</span>&#123;ll u=val%mod;ll v=rhs.val%mod;mint res;res.val=(u*v)%mod;<span class="hljs-keyword">return</span> res;&#125;&#125;;ostream &amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;out,<span class="hljs-keyword">const</span> mint &amp;rhs)&#123;out&lt;&lt;rhs.val;<span class="hljs-keyword">return</span> out;&#125;<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;ll res=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) res=res*a%mod;a=a*a%mod;n&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> res;&#125;mint inv2=mint(ksm(<span class="hljs-number">2</span>,mod<span class="hljs-number">-2</span>));mint inv6=mint(ksm(<span class="hljs-number">6</span>,mod<span class="hljs-number">-2</span>));ll n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n))&#123;ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">1000001</span>)&#123;mint m=mint(<span class="hljs-number">1e6</span>+<span class="hljs-number">1</span>);mint tn=mint(n);mint one=mint(<span class="hljs-number">1</span>);mint two=mint(<span class="hljs-number">2</span>);mint fi=(tn+one)*(tn-m+one)*(m+tn)*inv2;mint se=tn*(tn+one)*(tn*two+one)*inv6;mint th=(m-one)*m*(m*two-one)*inv6;mint t=fi-se+th;ll val=t.go();res=(res+val)%mod;&#125;ll rhs=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll a=<span class="hljs-number">2</span>;a&lt;=<span class="hljs-built_in">min</span>(<span class="hljs-number">1000000L</span>L,n);a++)&#123;ll sum=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">1</span>;ll l=a,r=a*a<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(r&gt;=n)&#123;r=<span class="hljs-built_in">min</span>(r,n);ll len=r-l+<span class="hljs-number">1</span>;sum=(sum+len%mod*cnt%mod)%mod;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> &#123;ll len=r-l+<span class="hljs-number">1</span>;sum=(sum+len%mod*cnt%mod)%mod;&#125;l=r+<span class="hljs-number">1</span>;r=l*a<span class="hljs-number">-1</span>;cnt++;&#125;sum=(sum*a)%mod;rhs=(rhs+sum)%mod;&#125;res=(res+rhs)%mod;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,res);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="K-Largest-Common-Submatrix"><a href="#K-Largest-Common-Submatrix" class="headerlink" title="K Largest Common Submatrix"></a>K Largest Common Submatrix</h2><p>看到这种最大子矩阵的题目,就应该第一时间想到悬线法和单调栈啊!!!</p><p>悬线法和单调栈的这类题目,我想我会单独再写一篇博客进行总结 <del>现在也没有学完</del></p><h3 id="单独利用悬线法的ac代码"><a href="#单独利用悬线法的ac代码" class="headerlink" title="单独利用悬线法的ac代码"></a>单独利用悬线法的ac代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv],b[maxv][maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> ax[maxv*maxv],ay[maxv*maxv];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">shu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span></span>&#123;<span class="hljs-keyword">int</span> delta=ax[p]-ax[q];<span class="hljs-keyword">if</span>(delta==<span class="hljs-number">-1</span> &amp;&amp; ay[p]==ay[q]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span></span>&#123;<span class="hljs-keyword">int</span> delta=ay[p]-ay[q];<span class="hljs-keyword">if</span>(delta==<span class="hljs-number">-1</span> &amp;&amp; ax[p]==ax[q]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">int</span> l[maxv][maxv],r[maxv][maxv],h[maxv][maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);ax[a[i][j]]=i,ay[a[i][j]]=j;l[i][j]=r[i][j]=j;h[i][j]=<span class="hljs-number">1</span>;&#125;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i][j]);<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment">cout&lt;&lt;"A\n";</span><span class="hljs-comment">inc(i,1,n) &#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",a[i][j]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">cout&lt;&lt;"B\n";</span><span class="hljs-comment">inc(i,1,n)&#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",b[i][j]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">2</span>,m) <span class="hljs-keyword">if</span>(hen(b[i][j<span class="hljs-number">-1</span>],b[i][j])) l[i][j]=l[i][j<span class="hljs-number">-1</span>];inc(i,<span class="hljs-number">1</span>,n) dec(j,m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span>(hen(b[i][j],b[i][j+<span class="hljs-number">1</span>])) r[i][j]=r[i][j+<span class="hljs-number">1</span>];inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span> &amp;&amp; shu(b[i<span class="hljs-number">-1</span>][j],b[i][j]))&#123;l[i][j]=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(l[i][j],l[i<span class="hljs-number">-1</span>][j]);r[i][j]=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>(r[i][j],r[i<span class="hljs-number">-1</span>][j]);h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> o1=r[i][j]-l[i][j]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> o2=h[i][j];ans=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(ans,o1*o2);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">cout&lt;&lt;" L -------------\n";</span><span class="hljs-comment">inc(i,1,n)&#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",l[i][j]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">cout&lt;&lt;" R --------------\n";</span><span class="hljs-comment">inc(i,1,n)&#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",r[i][j]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="单独利用单调栈的ac代码"><a href="#单独利用单调栈的ac代码" class="headerlink" title="单独利用单调栈的ac代码"></a>单独利用单调栈的ac代码</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// beta</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv],b[maxv][maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> ax[maxv*maxv],ay[maxv*maxv];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">shu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span></span>&#123;<span class="hljs-keyword">int</span> delta=ax[p]-ax[q];<span class="hljs-keyword">if</span>(delta==<span class="hljs-number">-1</span> &amp;&amp; ay[p]==ay[q]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span></span>&#123;<span class="hljs-keyword">int</span> delta=ay[p]-ay[q];<span class="hljs-keyword">if</span>(delta==<span class="hljs-number">-1</span> &amp;&amp; ax[p]==ax[q]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">int</span> st[maxv];<span class="hljs-keyword">int</span> s,t;<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-keyword">int</span> l[maxv],r[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);ax[a[i][j]]=i,ay[a[i][j]]=j;&#125;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i][j]);<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) inc(j,<span class="hljs-number">1</span>,m) val[j]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> &#123;inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(shu(b[i<span class="hljs-number">-1</span>][j],b[i][j])) val[j]++;<span class="hljs-keyword">else</span> val[j]=<span class="hljs-number">1</span>;&#125;s=t=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> L=<span class="hljs-number">1</span>,R=m;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> now=val[j];<span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span> || hen(b[i][j<span class="hljs-number">-1</span>],b[i][j])) ;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(s&lt;t) t--;L=j;&#125;<span class="hljs-comment">// val 和 st写反了 调试了半天:-|</span><span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) l[j]=L;<span class="hljs-keyword">else</span> l[j]=st[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[t++]=j;&#125;s=t=<span class="hljs-number">0</span>;dec(k,m,<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> now=val[k];<span class="hljs-keyword">if</span>(k==m || hen(b[i][k],b[i][k+<span class="hljs-number">1</span>])) ;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(s&lt;t) t--;R=k;&#125;<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) r[k]=R;<span class="hljs-keyword">else</span> r[k]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=k;&#125;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> a=r[j]-l[j]+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=val[j];ans=<span class="hljs-built_in">max</span>(ans,a*b);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="数据生成代码和对拍程序"><a href="#数据生成代码和对拍程序" class="headerlink" title="数据生成代码和对拍程序"></a>数据生成代码和对拍程序</h3><p>令人忧伤的是我利用悬线法写的第一份代码是有重大bug的(上面给出的代码bug已经修改),</p><p>但是依然神奇的通过了该题目, 所以带着对于数据的怀疑我又写了数据生成程序进行了对拍.</p><p>上述两种不同思路ac的代码对拍结果一致:-)</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;srand(time(<span class="hljs-number">0</span>));<span class="hljs-keyword">int</span> n=rand()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> m=rand()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;inc(i,<span class="hljs-number">1</span>,(n*m)) res.pb(i);<span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;m&lt;&lt;<span class="hljs-built_in">endl</span>;random_shuffle(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,res[cnt]);cnt++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;    <span class="hljs-comment">// 整个代码的灵魂</span>random_shuffle(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());cnt=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,res[cnt]);cnt++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 命名为bash.sh</span>cnt=0<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>./c &gt; data.in./a&lt;data.in&gt; a.out./b&lt;data.in&gt; b.outdiff a.out b.out<span class="hljs-keyword">if</span> [ $? -ne 0 ] ;<span class="hljs-keyword">then</span> <span class="hljs-built_in">break</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$cnt</span><span class="hljs-built_in">let</span> cnt=cnt+1<span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre></div><h2 id="and-more"><a href="#and-more" class="headerlink" title="and more"></a>and more</h2><p>事实上银川的这套题出的质量相当高了,考察了各种各样的能力,</p><p>不过可能有点依赖于平时的做题量,要不然有的知识点根本就不会啊(泪目).</p><p>网上也基本上可以找到对应题目的题解的: ) </p><p>D 是莫比乌斯反演,欧拉降幂</p><p>E 是长链剖分+ 套路</p><p>H 是tarjan+ dijkstra+神奇的建图</p><p>J 是圆方树?</p><p>L 是大力搜索吧 (好像实现比较难写)</p><p>总之这套题目的其他题还是有必要做的啊 :-)</p><p>在未来来临之前,把之前未完成的心愿完成吧.</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2019区域赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>模板留存</tag>
      
      <tag>2019区域赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调双端队列beta</title>
    <link href="/2020/10/06/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97beta/"/>
    <url>/2020/10/06/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97beta/</url>
    
    <content type="html"><![CDATA[<p>单调双端队列第二弹  :-)</p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>是2018年杭电多校的第三场 HDU6319</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6319" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6319</a></p><h2 id="题解链接"><a href="#题解链接" class="headerlink" title="题解链接"></a>题解链接</h2><p><a href="https://acm.taifua.com/archives/hdu6319.html" target="_blank" rel="noopener">https://acm.taifua.com/archives/hdu6319.html</a></p><p>看到这个区间长度为m的最值,的确是应该马上想到单调双端队列啊 :-| </p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e7</span>+<span class="hljs-number">70</span>;<span class="hljs-keyword">int</span> T,n,m,k,P,Q,R,MOD,i,a[maxn],q[maxn],s,t;ll A,B;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> gc() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)</span><span class="hljs-keyword">char</span> c;<span class="hljs-keyword">namespace</span> io &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> L=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)+<span class="hljs-number">1</span>;    <span class="hljs-keyword">char</span> ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L<span class="hljs-number">-1</span>,c,st[<span class="hljs-number">55</span>];<span class="hljs-keyword">int</span> f,tp;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">char</span> tc=gc();        <span class="hljs-keyword">while</span>(tc==<span class="hljs-number">10</span>)tc=gc();        <span class="hljs-keyword">return</span> tc;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;        fwrite(obuf,<span class="hljs-number">1</span>,oS-obuf,<span class="hljs-built_in">stdout</span>);        oS=obuf;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span> </span>&#123; *oS++=x; <span class="hljs-keyword">if</span> (oS==oT) <span class="hljs-built_in">flush</span>(); &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class I&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gi</span><span class="hljs-params">(I&amp;x)</span> </span>&#123;        <span class="hljs-keyword">for</span> (f=<span class="hljs-number">1</span>,c=gc();c&lt;<span class="hljs-string">'0'</span>||c&gt;<span class="hljs-string">'9'</span>;c=gc()) <span class="hljs-keyword">if</span> (c==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (x=<span class="hljs-number">0</span>;c&lt;=<span class="hljs-string">'9'</span>&amp;&amp;c&gt;=<span class="hljs-string">'0'</span>;c=gc()) x=x*<span class="hljs-number">10</span>+(c&amp;<span class="hljs-number">15</span>); x*=f;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class I&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(I x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!x) putc(<span class="hljs-string">'0'</span>);        <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>) putc(<span class="hljs-string">'-'</span>),x=-x;        <span class="hljs-keyword">while</span> (x) st[++tp]=x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>,x/=<span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span> (tp) putc(st[tp--]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*s, <span class="hljs-keyword">int</span>&amp;l)</span> </span>&#123;        <span class="hljs-keyword">for</span> (c=gc();c&lt;<span class="hljs-string">'a'</span>||c&gt;<span class="hljs-string">'z'</span>;c=gc());        <span class="hljs-keyword">for</span> (l=<span class="hljs-number">0</span>;c&lt;=<span class="hljs-string">'z'</span>&amp;&amp;c&gt;=<span class="hljs-string">'a'</span>;c=gc()) s[l++]=c;        s[l]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ps</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*s)</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,n=<span class="hljs-built_in">strlen</span>(s);i&lt;n;i++) putc(s[i]); &#125;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IOFLUSHER</span>&#123;</span> ~IOFLUSHER() &#123; <span class="hljs-built_in">flush</span>(); &#125; &#125; _ioflusher_;&#125;;<span class="hljs-keyword">using</span> io::getc;<span class="hljs-keyword">using</span> io::putc;<span class="hljs-keyword">using</span> io::gi;<span class="hljs-keyword">using</span> io::gs;<span class="hljs-keyword">using</span> io::ps;<span class="hljs-keyword">using</span> io::<span class="hljs-built_in">print</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// freopen("data.in","r",stdin);</span>    <span class="hljs-comment">//freopen("A.in","r",stdin);</span>    <span class="hljs-comment">//freopen("data.out","w",stdout);</span>    gi(T);    <span class="hljs-keyword">while</span>(T--)&#123;        gi(n);gi(m);gi(k);gi(P);gi(Q);gi(R);gi(MOD);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++) gi(a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=(<span class="hljs-number">1L</span>L*P*a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1L</span>L*Q*i+R)%MOD;        ll A=<span class="hljs-number">0</span>,B=<span class="hljs-number">0</span>;        s=t=<span class="hljs-number">0</span>;        A=B=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-comment">// 维护的是单调递减的单调双端队列</span><span class="hljs-comment">// 所以当队列中的元素&lt;= 要放入的元素时，要进行pop_back()的操作</span>            <span class="hljs-keyword">while</span>(s&lt;t&amp;&amp;a[q[t<span class="hljs-number">-1</span>]]&lt;=a[i]) t--;            q[t++]=i;            <span class="hljs-keyword">if</span>(i+m<span class="hljs-number">-1</span>&lt;=n)&#123;               <span class="hljs-keyword">while</span>(q[s]&gt;=i+m) s++;              <span class="hljs-comment">// printf("%d %d %d\n",i,a[q[s]],t-s);</span>               A+=i^a[q[s]];               B+=i^(t-s);            &#125;          <span class="hljs-comment">//  show();</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %lld\n"</span>,A,B);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>单调双端队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重温单调栈和单调队列</title>
    <link href="/2020/10/06/%E9%87%8D%E6%B8%A9%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2020/10/06/%E9%87%8D%E6%B8%A9%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>只是人生海海,不知何时能再相见.</p><a id="more"></a><p>单调栈和单调队列是非常基础的数据结构了吧,可以和很多东西结合,比如优化个dp什么的.</p><p>这里个人认为单调队列的叫法其实不太对,因为放元素的时候很多元素还是要用队尾出,只不过为了满足某些条件需要在队头pop_front一些元素,更合适的叫法应该叫 单调双端队列吧.</p><h2 id="单调栈可以做的事"><a href="#单调栈可以做的事" class="headerlink" title="单调栈可以做的事"></a>单调栈可以做的事</h2><p>对于某个元素$i $:</p><ul><li>确定左/右边区间第一个比它小/大的数</li><li>确定以该元素为最值的最长区间</li><li>确定这个元素是否为区间最值</li><li>确定以该元素为最值的最长区间</li></ul><h2 id="单调双端队列可以做的事"><a href="#单调双端队列可以做的事" class="headerlink" title="单调双端队列可以做的事"></a>单调双端队列可以做的事</h2><ul><li>可以查询区间最值</li><li>可以优化dp</li></ul><h2 id="poj2559"><a href="#poj2559" class="headerlink" title="poj2559"></a>poj2559</h2><p>寻找最大子矩形</p><p>单调栈 </p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;ll a[maxv];<span class="hljs-keyword">int</span> st[maxv];<span class="hljs-keyword">int</span> l[maxv],r[maxv];<span class="hljs-keyword">int</span> p;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,a+i);p=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;ll now=a[i];<span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span> &amp;&amp; a[st[p<span class="hljs-number">-1</span>]]&gt;=now) p--;<span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>) l[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> l[i]=st[p<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[p++]=i;&#125;p=<span class="hljs-number">0</span>;dec(i,n,<span class="hljs-number">1</span>)&#123;ll now=a[i];<span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span> &amp;&amp; a[st[p<span class="hljs-number">-1</span>]]&gt;=now) p--;<span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>) r[i]=n;<span class="hljs-keyword">else</span> r[i]=st[p<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[p++]=i;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">inc(i,1,n) cout&lt;&lt;l[i]&lt;&lt;" ";cout&lt;&lt;endl;</span><span class="hljs-comment">inc(i,1,n) cout&lt;&lt;r[i]&lt;&lt;" ";cout&lt;&lt;endl;</span><span class="hljs-comment">*/</span>ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;ll t=(r[i]-l[i]+<span class="hljs-number">1</span>)*a[i];res=<span class="hljs-built_in">max</span>(res,t);&#125;<span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="poj2823"><a href="#poj2823" class="headerlink" title="poj2823"></a>poj2823</h2><p>寻找长度为k的区间的最值</p><p>单调双端队列</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-keyword">int</span> n,k;<span class="hljs-keyword">int</span> st[maxv],s,t;<span class="hljs-keyword">int</span> Min[maxv],Max[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k))&#123;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);s=t=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">int</span> now=a[i];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; a[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;st[t++]=i;<span class="hljs-keyword">if</span>(i-k+<span class="hljs-number">1</span>&gt;=<span class="hljs-number">1</span>) Min[i-k+<span class="hljs-number">1</span>]=a[st[s]];<span class="hljs-keyword">if</span>(st[s]==i-k+<span class="hljs-number">1</span>) s++;&#125;s=t=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">int</span> now=a[i];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; a[st[t<span class="hljs-number">-1</span>]]&lt;=now) t--;st[t++]=i;<span class="hljs-keyword">if</span>(i-k+<span class="hljs-number">1</span>&gt;=<span class="hljs-number">1</span>) Max[i-k+<span class="hljs-number">1</span>]=a[st[s]];<span class="hljs-keyword">while</span>(st[s]&lt;=i-k+<span class="hljs-number">1</span>) s++;&#125;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">if</span>(i+k<span class="hljs-number">-1</span>&gt;n) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(flag++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,Min[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);flag=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">if</span>(i+k<span class="hljs-number">-1</span>&gt;n) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(flag++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,Max[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="poj2796"><a href="#poj2796" class="headerlink" title="poj2796"></a>poj2796</h2><p>单调双端队列</p><p>坑点: 如果所有的val都是0</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-keyword">int</span> n; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;ll val[maxv];ll st[maxv];<span class="hljs-keyword">int</span> s,t;<span class="hljs-keyword">int</span> l[maxv],r[maxv];ll sum[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,val+i);sum[i]=val[i]+sum[i<span class="hljs-number">-1</span>];&#125;s=t=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;ll now=val[i];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) l[i]=<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> l[i]=st[t<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;st[t++]=i;&#125;s=t=<span class="hljs-number">0</span>;dec(i,n,<span class="hljs-number">1</span>)&#123;ll now=val[i];<span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&gt;=now) t--;<span class="hljs-keyword">if</span>(s==t) r[i]=n;<span class="hljs-keyword">else</span> r[i]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=i;&#125;ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> tl,tr;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;ll t=(sum[r[i]]-sum[l[i]<span class="hljs-number">-1</span>])*val[i];<span class="hljs-keyword">if</span>(res&lt;t)&#123;res=t;tl=l[i];tr=r[i];&#125;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="hljs-string">"\n"</span>;<span class="hljs-comment">// 有可能所有的val都是0</span><span class="hljs-comment">// 那么需要特判</span><span class="hljs-keyword">if</span>(res)<span class="hljs-built_in">cout</span>&lt;&lt;tl&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;tr&lt;&lt;<span class="hljs-string">"\n"</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1 1\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="poj3250"><a href="#poj3250" class="headerlink" title="poj3250"></a>poj3250</h2><p>单调栈</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">8e4</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-keyword">int</span> st[maxv];<span class="hljs-keyword">int</span> r[maxv];<span class="hljs-keyword">int</span> s,t; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,val+i);s=t=<span class="hljs-number">0</span>;dec(i,n,<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> now=val[i];<span class="hljs-comment">// 是递减的单调栈</span><span class="hljs-comment">// 注意如果遇到相同的元素并不需要pop出去</span><span class="hljs-keyword">while</span>(s&lt;t &amp;&amp; val[st[t<span class="hljs-number">-1</span>]]&lt;now) t--;<span class="hljs-keyword">if</span>(s==t) r[i]=n;<span class="hljs-keyword">else</span> r[i]=st[t<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;st[t++]=i;&#125;ll res=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;ll t=r[i]-i;res+=t;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>end of glory</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调双端队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hdu5634[线段树]</title>
    <link href="/2020/09/21/hdu5634-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2020/09/21/hdu5634-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>我走过你来时的路.</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5634" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5634</a></p><p>加深了对于线段树多标记的理解.</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//339855262020-09-21 20:27:56Accepted56343010MS77568K2730 BG++mainland</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">// 因为prime的个数很明显达不到maxv的级别</span><span class="hljs-comment">// 这里如果不放心,可以打表来计算一下这里prime开多大比较合适</span><span class="hljs-keyword">int</span> prime[maxv/<span class="hljs-number">10</span>];<span class="hljs-keyword">bool</span> np[maxv];<span class="hljs-keyword">int</span> phi[maxv];<span class="hljs-keyword">int</span> tot;<span class="hljs-comment">// phi 是积性函数,所以可以利用筛来计算</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;tot=<span class="hljs-number">0</span>; np[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>; phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;inc(i,<span class="hljs-number">2</span>,n)&#123;<span class="hljs-keyword">if</span>(np[i]==<span class="hljs-literal">false</span>)&#123; prime[++tot]=i; phi[i]=i<span class="hljs-number">-1</span>; &#125;inc(j,<span class="hljs-number">1</span>,tot)&#123;<span class="hljs-keyword">if</span>(prime[j]*i&gt;n) <span class="hljs-keyword">break</span>;np[i*prime[j]]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;phi[i*prime[j]]=phi[i]*prime[j];<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> phi[i*prime[j]]=phi[i]*(prime[j]<span class="hljs-number">-1</span>);&#125;&#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span>    <span class="hljs-comment">// 表示该节点覆盖的是区间[l,r]</span><span class="hljs-keyword">int</span> l,r;    <span class="hljs-comment">// sum表示区间的和</span>    <span class="hljs-comment">// same==0 表示该区间内的数并不是相同的,</span>    <span class="hljs-comment">// 如果same!=0,表示区间内的数是相同的,且值为same</span>ll sum,same;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(x) tree[x].l</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(x) tree[x].r</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sum(x) tree[x].sum</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> same(x) tree[x].same</span>&#125;tree[N&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;sum(o)=sum(ls)+sum(rs);<span class="hljs-keyword">if</span>(same(ls)==same(rs)) same(o)=same(ls);<span class="hljs-keyword">else</span> same(o)=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(same(o))&#123;<span class="hljs-keyword">int</span> l=l(o);<span class="hljs-keyword">int</span> r=r(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;same(ls)=same(rs)=same(o);sum(ls)=<span class="hljs-number">1L</span>L*same(o)*(m-l+<span class="hljs-number">1</span>);sum(rs)=<span class="hljs-number">1L</span>L*same(o)*(r-m);same(o)=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123; l(o)=l;r(o)=r; <span class="hljs-keyword">if</span>(l==r) &#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;sum(o)); same(o)=sum(o);<span class="hljs-keyword">return</span> ; &#125; <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>; build(lson);build(rson); pushup(o); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123; <span class="hljs-keyword">int</span> l=l(o),r=r(o); <span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr &amp;&amp; same(o))&#123;same(o)=phi[same(o)];sum(o)=<span class="hljs-number">1L</span>L*same(o)*(r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> ;&#125;pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update1(ql,qr,ls);<span class="hljs-keyword">if</span>(m&lt;qr) update1(ql,qr,rs);pushup(o);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=l(o),r=r(o);<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp; r&lt;=qr)&#123;same(o)=x;sum(o)=<span class="hljs-number">1L</span>L*(r-l+<span class="hljs-number">1</span>)*x;<span class="hljs-keyword">return</span>;&#125;pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update2(ql,qr,x,ls);<span class="hljs-keyword">if</span>(m&lt;qr) update2(ql,qr,x,rs);pushup(o);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=l(o),r=r(o);<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> sum(o);pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;ll ret=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) ret+=query(ql,qr,ls);<span class="hljs-keyword">if</span>(m&lt;qr) ret+=query(ql,qr,rs);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;sieve(<span class="hljs-number">10000000</span>);<span class="hljs-keyword">bool</span> show=<span class="hljs-literal">true</span>; show=<span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> T;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-keyword">int</span> n,m;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> op;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;op);<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> l,r;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);update1(l,r,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">int</span> l,r,x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;x);update2(l,r,x,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> l,r;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,query(l,r,<span class="hljs-number">1</span>));&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
      <tag>end of glory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019南京区域赛</title>
    <link href="/2020/09/21/2019%E5%8D%97%E4%BA%AC%E5%8C%BA%E5%9F%9F%E8%B5%9B/"/>
    <url>/2020/09/21/2019%E5%8D%97%E4%BA%AC%E5%8C%BA%E5%9F%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>2019年南京区域赛 .</p><p>以下题目按照个人认为的难度顺序排列.</p><a id="more"></a><h2 id="题目连接"><a href="#题目连接" class="headerlink" title="题目连接"></a>题目连接</h2><p><a href="https://www.jisuanke.com/contest/5528/challenges" target="_blank" rel="noopener">https://www.jisuanke.com/contest/5528/challenges</a></p><h2 id="A-A-Hard-Problem"><a href="#A-A-Hard-Problem" class="headerlink" title="A. A Hard Problem"></a>A. A Hard Problem</h2><p>一般这种标题都是正话反说?</p><p>可能看到这个题之后,有灵感的人可以立马猜出结论.</p><p>我个人倾向于打表找规律,利用位运算枚举小数据的情况,得到一个大概结论的规律.</p><h3 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; chosen)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;chosen.<span class="hljs-built_in">size</span>();i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;chosen.<span class="hljs-built_in">size</span>();j++)<span class="hljs-keyword">if</span>(i!=j)&#123;<span class="hljs-keyword">int</span> a=chosen[i];<span class="hljs-keyword">int</span> b=chosen[j];<span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-keyword">if</span>(a%b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b%a==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span>  <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=((<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>);i++)&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&amp; i) vec.pb(j+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()==k) <span class="hljs-keyword">if</span>(ok(vec)==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment">int n,k;while(cin&gt;&gt;n&gt;&gt;k)&#123;</span><span class="hljs-comment">cout&lt;&lt;solve(n,k)&lt;&lt;endl;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">2</span>;n&lt;=<span class="hljs-number">20</span>;n++)&#123;<span class="hljs-keyword">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<span class="hljs-keyword">if</span>(solve(n,j)==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;ans=j;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" : "</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//ac</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">cout</span>&lt;&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="H-Prince-and-Princess"><a href="#H-Prince-and-Princess" class="headerlink" title="H Prince and Princess"></a>H Prince and Princess</h2><p>这个题在现场赛的时候坑了不少队伍,感觉一方面是题意杀,另一方面是1 0 0 这个数据可能没想到.</p><p>在这个题目当中,随机的人和存心捣乱的人可以看成一类人, </p><p>输入为1 0 0 的时候其实一个人都不用问了,因为只有一个人肯定是公主.</p><p>这个题目可能可以吸取的教训是从比较小的数据开始推算一下结果,可能就会把一些特殊情况规避掉.</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c))&#123;<span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>&amp;&amp;b==<span class="hljs-number">0</span>&amp;&amp;c==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n0\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;b+c) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n%d\n"</span>,<span class="hljs-number">2</span>*(b+c)+<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="K-Triangle"><a href="#K-Triangle" class="headerlink" title="K. Triangle"></a>K. Triangle</h2><p>一个较为基础的计算几何题目,二分的思路也非常好想.</p><p>计算几何非常容易写出问题,因为涉及到很多double的运算,往往是非常危险的,而且比较难出样例进行测试.</p><p>是时候需要整理一下计算几何的模板了.</p><p>下面放几份我通过的代码,细节实现略有不同.</p><h3 id="通过代码1"><a href="#通过代码1" class="headerlink" title="通过代码1"></a>通过代码1</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// first</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-6</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">double</span> x;  <span class="hljs-comment">//x坐标</span>    <span class="hljs-keyword">double</span> y;  <span class="hljs-comment">//y坐标</span>&#125;a,b,c,p;  <span class="hljs-comment">//定义点</span><span class="hljs-comment">//判断点是否在线上，在返回1，不在返回0</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">onSegement</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2,<span class="hljs-built_in">point</span> Q)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> maxx,minx,maxy,miny;    maxx = p1.x &gt;p2.x ?p1.x :p2.x ;    <span class="hljs-comment">//矩形的右边长</span>    minx = p1.x &gt;p2.x ?p2.x :p1.x ;     <span class="hljs-comment">//矩形的左边长</span>    maxy = p1.y &gt;p2.y ?p1.y :p2.y ;    <span class="hljs-comment">//矩形的上边长</span>    miny = p1.y &gt;p2.y ?p2.y :p1.y ;     <span class="hljs-comment">//矩形的下边长</span>    <span class="hljs-keyword">if</span>( ((Q.x -p1.x )*(p2.y -p1.y) == (p2.x -p1.x) *(Q.y -p1.y)) &amp;&amp; ( Q.x &gt;= minx &amp;&amp; Q.x &lt;= maxx ) &amp;&amp; ( Q.y &gt;= miny &amp;&amp; Q.y &lt;= maxy))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x1 x_1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y1 y_1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x2 x_2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y2 y_2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x3 x_3</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y3 y_3</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b,<span class="hljs-built_in">point</span> c)</span></span>&#123;<span class="hljs-keyword">double</span> x_1=a.x;<span class="hljs-keyword">double</span> y_1=a.y;<span class="hljs-keyword">double</span> x_2=b.x;<span class="hljs-keyword">double</span> y_2=b.y;<span class="hljs-keyword">double</span> x_3=c.x;<span class="hljs-keyword">double</span> y_3=c.y;<span class="hljs-keyword">double</span> ans=<span class="hljs-built_in">fabs</span>(<span class="hljs-number">0.5</span>*(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2));<span class="hljs-keyword">return</span> ans; <span class="hljs-comment">//  bug is here  我居然写了两次 - x_1*y_3   :|</span> <span class="hljs-comment">//  实际上第一份代码就是cal函数没写对,泪目 </span><span class="hljs-keyword">double</span> res=<span class="hljs-built_in">fabs</span>(<span class="hljs-number">0.5</span>*(x_1*y_2+x_2*y_3+x_3*y_1-x_1*y_3-x_1*y_3-x_2*y_1-x_3*y_2));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">double cal(point a,point b,point c)&#123;</span><span class="hljs-comment">double x_1=a.x;</span><span class="hljs-comment">double y_1=a.y;</span><span class="hljs-comment">double x_2=b.x;</span><span class="hljs-comment">double y_2=b.y;</span><span class="hljs-comment">double x_3=c.x;</span><span class="hljs-comment">double y_3=c.y;</span><span class="hljs-comment"></span><span class="hljs-comment">double res=fabs(0.5*(x_1*y_2+x_2*y_3+x_3*y_1-x_1*y_3-x_1*y_3-x_2*y_1-x_3*y_2));</span><span class="hljs-comment">return res;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;a.x,&amp;a.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;b.x,&amp;b.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;c.x,&amp;c.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;p.x,&amp;p.y);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x*<span class="hljs-number">2</span>-a.x-b.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y*<span class="hljs-number">2</span>-a.y-b.y) &lt;eps) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.12f %.12f\n"</span>,c.x,c.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x*<span class="hljs-number">2</span>-a.x-c.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y*<span class="hljs-number">2</span>-a.y-c.y)&lt;eps) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.12f %.12f\n"</span>,b.x,b.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x*<span class="hljs-number">2</span>-b.x-c.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y*<span class="hljs-number">2</span>-b.y-c.y)&lt;eps)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.12f %.12f\n"</span>,a.x,b.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(onSegement(a,b,p)) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(onSegement(b,c,p)) swap(a,c);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(onSegement(a,c,p)) swap(b,c);<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">double</span> area1=cal(a,p,c);<span class="hljs-keyword">double</span> area2=cal(b,p,c);<span class="hljs-keyword">if</span>(area1&gt;=area2) ;<span class="hljs-keyword">else</span> swap(a,b);<span class="hljs-keyword">double</span> area=cal(a,b,c)*<span class="hljs-number">0.5</span>;<span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1000</span>;<span class="hljs-built_in">point</span> ans;<span class="hljs-keyword">while</span>(cnt--)&#123;<span class="hljs-keyword">double</span> m=(l+r)*<span class="hljs-number">0.5</span>;<span class="hljs-built_in">point</span> pos;pos.x=a.x+(c.x-a.x)*m;pos.y=a.y+(c.y-a.y)*m;<span class="hljs-keyword">double</span> tmp=cal(pos,a,p);ans.x=pos.x;ans.y=pos.y;<span class="hljs-keyword">if</span>(tmp&lt;area) l=m;<span class="hljs-keyword">else</span> r=m;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,ans.x,ans.y);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="通过代码2"><a href="#通过代码2" class="headerlink" title="通过代码2"></a>通过代码2</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long #<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> db double</span><span class="hljs-keyword">const</span> db eps=<span class="hljs-number">1e-9</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">point</span>&#123;</span> <span class="hljs-keyword">public</span>:<span class="hljs-keyword">double</span> x;<span class="hljs-keyword">double</span> y;<span class="hljs-built_in">point</span>(<span class="hljs-keyword">double</span> x_=<span class="hljs-number">0</span>,<span class="hljs-keyword">double</span> y_=<span class="hljs-number">0</span>):x(x_),y(y_)&#123;&#125; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p2)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(p1.x+p2.x,p1.y+p2.y);&#125;;<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p2)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(p1.x-p2.x,p1.y-p2.y);&#125;;<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p,<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; m)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(p.x*m,p.y*m);&#125;;<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; m,<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(p.x*m,p.y*m);&#125;;<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; p,<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; m)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(p.x/m,p.y/m);&#125;;<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream&amp; out,<span class="hljs-built_in">point</span>&amp; a)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%lf,%lf)"</span>,a.x,a.y);<span class="hljs-keyword">return</span> out;&#125;;&#125;a,b,c,p;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">point</span> vect2;<span class="hljs-comment">//重命名，向量也是用坐标表示 </span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">point</span> start;<span class="hljs-built_in">point</span> <span class="hljs-built_in">end</span>; <span class="hljs-built_in">line</span>(<span class="hljs-built_in">point</span> s=<span class="hljs-built_in">point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-built_in">point</span> e=<span class="hljs-built_in">point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)):start(s),<span class="hljs-built_in">end</span>(e)&#123;&#125;&#125;; <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-built_in">point</span> O,<span class="hljs-built_in">point</span> A,<span class="hljs-built_in">point</span> B)</span></span>&#123;<span class="hljs-comment">//叉乘 </span><span class="hljs-keyword">double</span> oa_x=A.x-O.x;<span class="hljs-keyword">double</span> oa_y=A.y-O.y;<span class="hljs-keyword">double</span> ob_x=B.x-O.x;<span class="hljs-keyword">double</span> ob_y=B.y-O.y;<span class="hljs-keyword">return</span> oa_x*ob_y-oa_y*ob_x;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pointIsOnLine</span><span class="hljs-params">(<span class="hljs-built_in">point</span> O,<span class="hljs-built_in">line</span> L)</span></span>&#123;<span class="hljs-built_in">point</span> S=L.start;<span class="hljs-built_in">point</span> E=L.<span class="hljs-built_in">end</span>;<span class="hljs-keyword">if</span>(cross(O,S,E)==<span class="hljs-number">0</span><span class="hljs-comment">//在直线L上 </span><span class="hljs-keyword">and</span> <span class="hljs-built_in">min</span>(S.x,E.x)&lt;=O.x&amp;&amp;O.x&lt;=<span class="hljs-built_in">max</span>(S.x,E.x)<span class="hljs-keyword">and</span> <span class="hljs-built_in">min</span>(S.y,E.y)&lt;=O.y&amp;&amp;O.y&lt;=<span class="hljs-built_in">max</span>(S.y,E.y))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b,<span class="hljs-built_in">point</span> c)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(<span class="hljs-number">0.5</span>*cross(a,b,c));&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">double cal(point a,point b,point c)&#123;</span><span class="hljs-comment">db dis1=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><span class="hljs-comment">db dis2=sqrt((a.x-c.x)*(a.x-c.x)+(a.y-c.y)*(a.y-c.y));</span><span class="hljs-comment">db dis3=sqrt((b.x-c.x)*(b.x-c.x)+(b.y-c.y)*(b.y-c.y));</span><span class="hljs-comment"></span><span class="hljs-comment">double aa=dis1;</span><span class="hljs-comment">double bb=dis2;</span><span class="hljs-comment">double cc=dis3;</span><span class="hljs-comment">double p=0.5*(aa+bb+cc);</span><span class="hljs-comment">return sqrt(p*(p-aa)*(p-bb)*(p-cc));</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-built_in">point</span> <span class="hljs-title">getMid</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>(<span class="hljs-number">0.5</span>*(a.x+b.x),<span class="hljs-number">0.5</span>*(a.y+b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;a.x,&amp;a.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;b.x,&amp;b.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;c.x,&amp;c.y);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;p.x,&amp;p.y);<span class="hljs-built_in">line</span> ab=<span class="hljs-built_in">line</span>(a,b);<span class="hljs-built_in">line</span> bc=<span class="hljs-built_in">line</span>(b,c);<span class="hljs-built_in">line</span> ac=<span class="hljs-built_in">line</span>(a,c);<span class="hljs-keyword">if</span>(pointIsOnLine(p,ab)) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pointIsOnLine(p,bc)) swap(a,c);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pointIsOnLine(p,ac)) swap(b,c);<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//--------------------------------------------------------------</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x-a.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y-a.y)&lt;eps) &#123;<span class="hljs-built_in">point</span> o=getMid(b,c);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,o.x,o.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x-b.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y-b.y) &lt; eps)&#123;<span class="hljs-built_in">point</span> o=getMid(a,c);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,o.x,o.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p.x-c.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(p.y-c.y) &lt;eps) &#123;<span class="hljs-built_in">point</span> o=getMid(a,b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,o.x,o.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">point</span> o=getMid(b,c);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(o.x-p.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(o.y-p.y)&lt;eps) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,a.x,a.y);<span class="hljs-keyword">continue</span>;&#125;o=getMid(a,b);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(o.x-p.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(o.y-p.y) &lt; eps)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,c.x,c.y);<span class="hljs-keyword">continue</span>;&#125;o=getMid(a,c);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(o.x-p.x)&lt;eps &amp;&amp; <span class="hljs-built_in">fabs</span>(o.y-p.y) &lt;eps)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,b.x,b.y);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//--------------------------------------------------------------</span><span class="hljs-keyword">double</span> area1=getArea(a,p,c);<span class="hljs-keyword">double</span> area2=getArea(b,p,c);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(area1-area2)&lt;eps) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(area1&lt;area2)  swap(a,b);<span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1</span>;<span class="hljs-keyword">double</span> area=getArea(a,b,c)*<span class="hljs-number">0.5</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1000</span>;<span class="hljs-keyword">while</span>(cnt--)&#123;<span class="hljs-keyword">double</span> m=(l+r)*<span class="hljs-number">0.5</span>;<span class="hljs-built_in">point</span> pos;pos.x=a.x+(c.x-a.x)*m;pos.y=a.y+(c.y-a.y)*m;<span class="hljs-keyword">double</span> tmp=getArea(pos,a,p);<span class="hljs-keyword">if</span>(tmp&lt;area) l=m;<span class="hljs-keyword">else</span> r=m;&#125;<span class="hljs-keyword">double</span> delta=l;<span class="hljs-built_in">point</span> ans;ans.x=a.x+(c.x-a.x)*delta;ans.y=a.y+(c.y-a.y)*delta;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f %.15f\n"</span>,ans.x,ans.y);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="D-Digital-Path"><a href="#D-Digital-Path" class="headerlink" title="D. Digital Path"></a>D. Digital Path</h2><p>记忆化搜索,本质上是一个有向无环图,这就很适合使用dp来解决这个问题.</p><p>一个可能的坑点是 -2 -1 0 1 2 这种链也是符合条件的.</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv][maxv];ll dp[maxv][maxv][<span class="hljs-number">6</span>];<span class="hljs-keyword">bool</span> vis[maxv][maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;y&lt;=m) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">int</span> dx[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">if</span>(vis[x][y]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span><span class="hljs-keyword">bool</span> flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">int</span> tx=x+dx[i];<span class="hljs-keyword">int</span> ty=y+dy[i];<span class="hljs-comment">/*</span><span class="hljs-comment">   cout&lt;&lt;"tx "&lt;&lt;tx&lt;&lt;" ty "&lt;&lt;ty&lt;&lt;endl;</span><span class="hljs-comment">   cout&lt;&lt;in(tx,ty)&lt;&lt;endl;</span><span class="hljs-comment">   */</span><span class="hljs-keyword">if</span>(in(tx,ty))&#123;<span class="hljs-keyword">if</span>(a[x][y]==a[tx][ty]+<span class="hljs-number">1</span>) &#123;foo(tx,ty);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;dp[x][y][i+<span class="hljs-number">1</span>]+=dp[tx][ty][i];dp[x][y][i+<span class="hljs-number">1</span>]%=mod;&#125;dp[x][y][<span class="hljs-number">4</span>]+=dp[tx][ty][<span class="hljs-number">4</span>];dp[x][y][<span class="hljs-number">4</span>]%=mod;&#125;&#125;&#125;vis[x][y]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);dp[i][j][<span class="hljs-number">0</span>]=dp[i][j][<span class="hljs-number">1</span>]=dp[i][j][<span class="hljs-number">2</span>]=dp[i][j][<span class="hljs-number">3</span>]=dp[i][j][<span class="hljs-number">4</span>]=<span class="hljs-number">0</span>;vis[i][j]=<span class="hljs-number">0</span>;&#125;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) &#123;<span class="hljs-keyword">int</span> o=<span class="hljs-number">0</span>;inc(k,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&#123;<span class="hljs-keyword">int</span> x=i,y=j,tx=dx[k]+i,ty=dy[k]+j;<span class="hljs-keyword">if</span>(in(tx,ty))&#123;<span class="hljs-keyword">if</span>(a[tx][ty]+<span class="hljs-number">1</span>==a[x][y]) o++;&#125;&#125;<span class="hljs-keyword">if</span>(o==<span class="hljs-number">0</span>) dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,vis[i][j]=<span class="hljs-number">1</span>;&#125;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) foo(i,j);<span class="hljs-comment">/*</span><span class="hljs-comment">inc(i,1,n)&#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",dp[i][j][3]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">inc(i,1,n) &#123;</span><span class="hljs-comment">inc(j,1,m) printf("%4d",dp[i][j][4]);</span><span class="hljs-comment">putchar('\n');</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span>ll res=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> chu=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> x=i,y=j;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">3</span>;k++)&#123;<span class="hljs-keyword">int</span> tx=x+dx[k];<span class="hljs-keyword">int</span> ty=y+dy[k];<span class="hljs-keyword">if</span>(a[tx][ty]==a[x][y]+<span class="hljs-number">1</span>) chu++;&#125;<span class="hljs-keyword">if</span>(chu==<span class="hljs-number">0</span>) res=(res+dp[x][y][<span class="hljs-number">4</span>])%mod;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,res);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="J-Spy"><a href="#J-Spy" class="headerlink" title="J. Spy"></a>J. Spy</h2><p>感觉是很巧妙的,略微有点题意杀.</p><p>利用了二分图最大权匹配的模型,KM算法各种资料上都是 $n^4$的,或者有的模板号称是$n^3$,但是其实很慢.</p><p>如果现场赛没有合适的模板就会gg,还是平时注重积累吧.</p><p><a href="https://blog.csdn.net/qq_43497140/article/details/103337606" target="_blank" rel="noopener">https://blog.csdn.net/qq_43497140/article/details/103337606</a> </p><p>这个代码的 KM算法部分 是网上找的,有时间自己研究一下KM算法具体的原理,暂时把这个代码加入模板吧.</p><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">400</span>+<span class="hljs-number">10</span>;ll a[maxv],p[maxv],b[maxv],c[maxv];<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=maxv;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> nx,ny;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> g w</span><span class="hljs-keyword">int</span> g[N][N];<span class="hljs-keyword">int</span> linker[N];ll lx[N],ly[N];ll slack[N];<span class="hljs-keyword">bool</span> visx[N],visy[N];ll pre[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">( ll k )</span></span>&#123;    ll x , y = <span class="hljs-number">0</span> , yy = <span class="hljs-number">0</span> , delta;    <span class="hljs-built_in">memset</span>( pre , <span class="hljs-number">0</span> , <span class="hljs-keyword">sizeof</span>(pre) );    <span class="hljs-keyword">for</span>( ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i++ ) slack[i] = LONG_MAX;    linker[y] = k;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        x = linker[y]; delta = LONG_MAX; visy[y] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>( ll i = <span class="hljs-number">1</span> ; i &lt;= n ;i++ )&#123;            <span class="hljs-keyword">if</span>( !visy[i] )&#123;                <span class="hljs-keyword">if</span>( slack[i] &gt; lx[x] + ly[i] - w[x][i] )&#123;                    slack[i] = lx[x] + ly[i] - w[x][i];                    pre[i] = y;                &#125;                <span class="hljs-keyword">if</span>( slack[i] &lt; delta ) delta = slack[i] , yy = i ;            &#125;        &#125;        <span class="hljs-keyword">for</span>( ll i = <span class="hljs-number">0</span> ; i &lt;= n ; i++ )&#123;            <span class="hljs-keyword">if</span>( visy[i] ) lx[linker[i]] -= delta , ly[i] += delta;            <span class="hljs-keyword">else</span> slack[i] -= delta;        &#125;        y = yy ;        <span class="hljs-keyword">if</span>( linker[y] == <span class="hljs-number">-1</span> ) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">while</span>( y ) linker[y] = linker[pre[y]] , y = pre[y];&#125; <span class="hljs-function">ll <span class="hljs-title">KM</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>( lx , <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(lx) );    <span class="hljs-built_in">memset</span>( ly , <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(ly) );    <span class="hljs-built_in">memset</span>( linker , <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(linker) );    <span class="hljs-keyword">for</span>( ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i++ )&#123;        <span class="hljs-built_in">memset</span>( visy , <span class="hljs-literal">false</span> , <span class="hljs-keyword">sizeof</span>(visy) );        bfs(i);    &#125;    ll res = <span class="hljs-number">0</span> ;        <span class="hljs-keyword">for</span>( ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i++ )&#123;            <span class="hljs-keyword">if</span>( linker[i] != <span class="hljs-number">-1</span> )&#123;                res += w[linker[i]][i] ;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-comment">/*</span><span class="hljs-comment">bool DFS(int x)&#123;</span><span class="hljs-comment">visx[x] = true;</span><span class="hljs-comment">for(int y = 0; y &lt; ny; y++)&#123;</span><span class="hljs-comment">if(visy[y])continue;</span><span class="hljs-comment">ll tmp = lx[x] + ly[y]-g[x][y];</span><span class="hljs-comment">if(tmp == 0)&#123;</span><span class="hljs-comment">visy[y] = true;</span><span class="hljs-comment">if(linker[y] == -1 || DFS(linker[y]))&#123;</span><span class="hljs-comment">linker[y] = x;</span><span class="hljs-comment">return true;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">else if(slack[y] &gt; tmp)</span><span class="hljs-comment">slack[y] = tmp;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">return false;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">ll  KM()&#123;</span><span class="hljs-comment">memset(linker,-1,sizeof(linker));</span><span class="hljs-comment">memset(ly,0,sizeof(ly));</span><span class="hljs-comment">for(int i = 0;i &lt; nx;i++)&#123;</span><span class="hljs-comment">lx[i] = LONG_MIN;</span><span class="hljs-comment">for(int j = 0;j &lt; ny;j++)</span><span class="hljs-comment">if(g[i][j] &gt; lx[i])</span><span class="hljs-comment">lx[i] = g[i][j];</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">for(int x = 0;x &lt; nx;x++)&#123;</span><span class="hljs-comment">for(int i = 0;i &lt; ny;i++)</span><span class="hljs-comment">slack[i] = LONG_MAX;</span><span class="hljs-comment">while(true)&#123;</span><span class="hljs-comment">memset(visx,false,sizeof(visx));</span><span class="hljs-comment">memset(visy,false,sizeof(visy));</span><span class="hljs-comment">if(DFS(x))break;</span><span class="hljs-comment">ll  d = LONG_MAX;</span><span class="hljs-comment">for(int i = 0;i &lt; ny;i++)</span><span class="hljs-comment">if(!visy[i] &amp;&amp; d &gt; slack[i])</span><span class="hljs-comment">d = slack[i];</span><span class="hljs-comment">for(int i = 0;i &lt; nx;i++)</span><span class="hljs-comment">if(visx[i])</span><span class="hljs-comment">lx[i]-= d;</span><span class="hljs-comment">for(int i = 0;i &lt; ny;i++)&#123;</span><span class="hljs-comment">if(visy[i])ly[i] += d;</span><span class="hljs-comment">else slack[i]-= d;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">ll res = 0;</span><span class="hljs-comment">for(int i = 0;i &lt; ny;i++)</span><span class="hljs-comment">if(linker[i] != -1)</span><span class="hljs-comment">res += g[linker[i]][i];</span><span class="hljs-comment">return res;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getw</span><span class="hljs-params">()</span></span>&#123;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,a+i);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,p+i);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,b+i);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,c+i);inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,n) &#123;w[i][j]=<span class="hljs-number">0</span>;ll v=b[i]+c[j];inc(k,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(v&gt;a[k]) w[i][j]+=p[k];&#125;&#125;<span class="hljs-keyword">bool</span> show=<span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;getw();nx=ny=n;<span class="hljs-keyword">if</span>(show)inc(i,<span class="hljs-number">1</span>,n) &#123;inc(j,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%4lld"</span>,w[i][j]);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,KM());&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="B-chessboard"><a href="#B-chessboard" class="headerlink" title="B. chessboard"></a>B. chessboard</h2><p>lucas定理在这个题目中作为了STL一样的工具性存在.</p><p>这个题目真的是太太太太难读了!!!</p><p>我说一个我认为是正确的理解: 要保证在涂格子的任何时刻,已经涂的格子中任何两个在已涂格子上的距离等于曼哈顿距离.</p><p>另外一个困难就是要得到得到最后结果的公式,感觉挺需要数学直觉的.</p><p>可能需要场上自己想一些小样例之后大力猜结论.</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;ll a[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123; a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; inc(i,<span class="hljs-number">1</span>,<span class="hljs-number">2000000</span>) a[i]=a[i<span class="hljs-number">-1</span>]*i%mod; &#125;<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,ll n,ll p)</span></span>&#123;ll res=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(n)&#123;<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) res=res*a%p;a=a*a%p;n&gt;&gt;=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">c</span><span class="hljs-params">(ll n,ll m,ll p)</span></span>&#123;<span class="hljs-keyword">if</span>(n&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> a[n]*ksm(a[m],p<span class="hljs-number">-2</span>,p)%p*ksm(a[n-m],p<span class="hljs-number">-2</span>,p)%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;init();<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;ll n,m;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m);<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;m==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span> || <span class="hljs-number">1</span>==m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,<span class="hljs-number">4L</span>L*c(n+m<span class="hljs-number">-2</span>,n<span class="hljs-number">-1</span>,mod)%mod);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="and-More"><a href="#and-More" class="headerlink" title="and More"></a>and More</h2><p><a href="https://www.cnblogs.com/bringlu/p/12285181.html" target="_blank" rel="noopener">https://www.cnblogs.com/bringlu/p/12285181.html</a></p><p><a href="https://blog.csdn.net/qq_18125607/article/details/103351401" target="_blank" rel="noopener">https://blog.csdn.net/qq_18125607/article/details/103351401</a></p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2019区域赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>模板留存</tag>
      
      <tag>2019区域赛</tag>
      
      <tag>lucas定理</tag>
      
      <tag>km算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用fhqTreap解决区间序列问题</title>
    <link href="/2020/09/09/%E5%88%A9%E7%94%A8fhqTreap%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/09/%E5%88%A9%E7%94%A8fhqTreap%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>利用fhq treap 解决了一道区间序列的问题.</p><p>题目是2020hdu多校第9场的一个题目.</p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6873" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6873</a></p><h2 id="代码留存"><a href="#代码留存" class="headerlink" title="代码留存"></a>代码留存</h2><pre><code class="hljs c++"><span class="hljs-comment">// 338974762020-09-09 23:28:50Accepted68733556MS8516K3787BG++mainland </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">//by Sshwy</span><span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SZ = <span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-comment">// fhq treap 的模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">Treap</span>&#123;</span><span class="hljs-keyword">int</span> root,tot;<span class="hljs-keyword">int</span> mem[SZ],memp;<span class="hljs-keyword">int</span> lc[SZ],rc[SZ],sz[SZ];<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rnd[SZ];T val[SZ],mn[SZ];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s[SZ];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">fill</span>(lc,lc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(rc,rc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(sz,sz+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);root=tot=<span class="hljs-number">0</span>;&#125;Treap()&#123;root=tot=<span class="hljs-number">0</span>;srand(clock()+time(<span class="hljs-number">0</span>));s[<span class="hljs-number">0</span>] = val[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;mn[<span class="hljs-number">0</span>]=<span class="hljs-number">1e9</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;sz[u] = sz[lc[u]]+sz[rc[u]]+<span class="hljs-number">1</span>;mn[u] = <span class="hljs-built_in">min</span>(val[u],<span class="hljs-built_in">min</span>(mn[lc[u]],mn[rc[u]]));s[u]=s[lc[u]]+s[rc[u]]+val[u];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> left_size,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!u)<span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(sz[lc[u]]+<span class="hljs-number">1</span>&lt;=left_size)x=u,split(rc[u],left_size-sz[lc[u]]<span class="hljs-number">-1</span>,rc[u],y);<span class="hljs-keyword">else</span> y=u,split(lc[u],left_size,x,lc[u]);pushup(u);&#125;<span class="hljs-comment">//按住权值拆分为两颗子树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">const</span> T k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(val[now]&lt;=k) x=now,split_by_val(rc[now],k,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_val(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-comment">//按照排名拆分成两颗子树</span><span class="hljs-comment">//和split其实是一样的　k = left_size</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_rank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(sz[lc[now]]+<span class="hljs-number">1</span>&lt;=k) x=now,split_by_rank(rc[now],k-sz[lc[now]]<span class="hljs-number">-1</span>,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_rank(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-comment">//x,y两个子树,且所有的节点的值都小于y的所有节点的值</span><span class="hljs-comment">//随机权重以小根堆的形式存储</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//x&lt;y</span><span class="hljs-keyword">if</span>(!x||!y)<span class="hljs-keyword">return</span> x+y;<span class="hljs-comment">//if(rand()%(sz[x]+sz[y])&lt;sz[x])return rc[x]=merge(rc[x],y), pushup(x), x;</span><span class="hljs-keyword">if</span>(rnd[x]&lt;rnd[y])<span class="hljs-keyword">return</span> rc[x]=merge(rc[x],y), pushup(x), x;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> lc[y]=merge(x,lc[y]), pushup(y), y;&#125;<span class="hljs-comment">//虽然可能不满足堆的性质，但是，堆在这个过程中只是调节树的平衡的，所以还是可以过的</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * a, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> u=++tot,mid=l+r&gt;&gt;<span class="hljs-number">1</span>;s[u]=val[u]=mn[u]=a[mid],sz[u]=r-l+<span class="hljs-number">1</span>,rnd[u]=rand();lc[u]=dfs(a,l,mid<span class="hljs-number">-1</span>);rc[u]=dfs(a,mid+<span class="hljs-number">1</span>,r);pushup(u);<span class="hljs-keyword">return</span> u;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_from</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;root=dfs(a,l,r);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_seq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,T *p)</span></span>&#123;<span class="hljs-keyword">if</span>(u==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;dfs_seq(lc[u],p);*(p+sz[lc[u]]+<span class="hljs-number">1</span>) = val[u];dfs_seq(rc[u],p+sz[lc[u]]+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq</span><span class="hljs-params">(T *p)</span></span>&#123;dfs_seq(root,p);&#125;<span class="hljs-function">T <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<span class="hljs-keyword">int</span> u=root;<span class="hljs-keyword">while</span>(k!=sz[lc[u]]+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(k&lt;=sz[lc[u]]) u=lc[u];<span class="hljs-keyword">else</span> k-=sz[lc[u]]+<span class="hljs-number">1</span>,u=rc[u];&#125;<span class="hljs-keyword">return</span> val[u];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> right_mn,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(mn[rc[now]]&lt;right_mn || val[now]&lt; right_mn)x=now,split_by_min(rc[now],right_mn,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_min(lc[now],right_mn,x,lc[now]);pushup(now);&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">perform</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">if</span>(kth(x)&lt;y) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> L,R;split_by_rank(root,x,L,R);<span class="hljs-keyword">if</span>(mn[L]&gt;=y) &#123;root=merge(L,R);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">int</span> l,r;split_by_min(L,y,l,r);<span class="hljs-keyword">int</span> l1,l2,r1,r2;ll res=s[r]-sz[r]*<span class="hljs-number">1L</span>L*(y<span class="hljs-number">-1</span>);split(l,sz[l]<span class="hljs-number">-1</span>,l1,l2);split(r,<span class="hljs-number">1</span>,r1,r2);val[l2]+=val[r1]-(y<span class="hljs-number">-1</span>);s[l2]=mn[l2]=val[l2];s[r1]=mn[r1]=val[r1]=y<span class="hljs-number">-1</span>;root=merge(merge(merge(l1,l2),merge(r2,r1)),R);<span class="hljs-keyword">return</span> res;&#125;&#125;;Treap&lt;<span class="hljs-keyword">int</span>&gt; T;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> b[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q);T.<span class="hljs-built_in">clear</span>();inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,b+i);T.build_from(b,<span class="hljs-number">1</span>,n);inc(i,<span class="hljs-number">1</span>,q)&#123;<span class="hljs-keyword">int</span> op,x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;op,&amp;x);<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;y),<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,T.perform(x,y));<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,T.kth(x));&#125;T.seq(b);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d%c"</span>,b[i],<span class="hljs-string">" \n"</span>[i==n]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--) go();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>模板留存</tag>
      
      <tag>fhq treap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探fhq treap [alpha]</title>
    <link href="/2020/09/09/%E5%88%9D%E6%8E%A2fhqTreap/"/>
    <url>/2020/09/09/%E5%88%9D%E6%8E%A2fhqTreap/</url>
    
    <content type="html"><![CDATA[<p>也是平衡树大家族的一员．</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="　参考资料"></a>　参考资料</h2><p><a href="https://www.cnblogs.com/Axjcy/p/9475285.htm" target="_blank" rel="noopener">https://www.cnblogs.com/Axjcy/p/9475285.htm</a></p><p><a href="https://www.jvruo.com/archives/375/#FHQ-Treap" target="_blank" rel="noopener">https://www.jvruo.com/archives/375/#FHQ-Treap</a></p><p><a href="https://wenku.baidu.com/view/a5f6fefe0066f5335a8121fa.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a5f6fefe0066f5335a8121fa.html</a></p><p><a href="https://blog.csdn.net/CABI_ZGX/article/details/79963427" target="_blank" rel="noopener">https://blog.csdn.net/CABI_ZGX/article/details/79963427</a></p><h2 id="普通平衡树"><a href="#普通平衡树" class="headerlink" title="普通平衡树　"></a>普通平衡树　</h2><p><a href="https://loj.ac/problem/104" target="_blank" rel="noopener">题目链接</a></p><p>下面放两个代码吧，是不同的代码风格</p><p>个人更喜欢第一个版本的代码</p><h3 id="代码version1"><a href="#代码version1" class="headerlink" title="代码version1"></a>代码version1</h3><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-comment">// 104 普通平衡树</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">//by Sshwy</span><span class="hljs-keyword">namespace</span> RA&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l*rand()*rand()%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span>&#123;<span class="hljs-keyword">return</span> rnd(R-L+<span class="hljs-number">1</span>)+L;&#125;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SZ = <span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<span class="hljs-comment">// fhq treap 的模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">Treap</span>&#123;</span><span class="hljs-keyword">int</span> root,tot;<span class="hljs-keyword">int</span> mem[SZ],memp;<span class="hljs-keyword">int</span> lc[SZ],rc[SZ],sz[SZ];<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rnd[SZ];T val[SZ];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">fill</span>(lc,lc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(rc,rc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(sz,sz+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);root=tot=<span class="hljs-number">0</span>;&#125;Treap()&#123;root=tot=<span class="hljs-number">0</span>;srand(clock()+time(<span class="hljs-number">0</span>));val[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;sz[u] = sz[lc[u]]+sz[rc[u]]+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> left_size,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!u)<span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(sz[lc[u]]+<span class="hljs-number">1</span>&lt;=left_size)x=u,split(rc[u],left_size-sz[lc[u]]<span class="hljs-number">-1</span>,rc[u],y);<span class="hljs-keyword">else</span> y=u,split(lc[u],left_size,x,lc[u]);pushup(u);&#125;<span class="hljs-comment">//按住权值拆分为两颗子树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">const</span> T k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(val[now]&lt;=k) x=now,split_by_val(rc[now],k,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_val(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-comment">//按照排名拆分成两颗子树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_rank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();<span class="hljs-keyword">if</span>(sz[lc[now]]+<span class="hljs-number">1</span>&lt;=k) x=now,split_by_rank(rc[now],k-sz[lc[now]]<span class="hljs-number">-1</span>,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_rank(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-comment">//x,y两个子树,且所有的节点的值都小于y的所有节点的值</span><span class="hljs-comment">//随机权重以小根堆的形式存储</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//x&lt;y</span><span class="hljs-keyword">if</span>(!x||!y)<span class="hljs-keyword">return</span> x+y;<span class="hljs-comment">//if(rand()%(sz[x]+sz[y])&lt;sz[x])return rc[x]=merge(rc[x],y), pushup(x), x;</span><span class="hljs-keyword">if</span>(rnd[x]&lt;rnd[y])<span class="hljs-keyword">return</span> rc[x]=merge(rc[x],y), pushup(x), x;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> lc[y]=merge(x,lc[y]), pushup(y), y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T v)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,u=memp?mem[memp--]:++tot;val[u]=v;sz[u]=<span class="hljs-number">1</span>;rnd[u]=rand();split_by_val(root,v,a,b);root=merge(merge(a,u),b);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c,d,e,f;split_by_val(root,x,a,b);split_by_val(a,x<span class="hljs-number">-1</span>,c,d);split_by_rank(d,<span class="hljs-number">1</span>,e,f);root=merge(merge(c,f),b);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRank</span><span class="hljs-params">(T x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c;split_by_val(root,x<span class="hljs-number">-1</span>,a,b);c=sz[a]+<span class="hljs-number">1</span>;root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">T <span class="hljs-title">findK</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;rot,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c,d;split_by_rank(rot,x<span class="hljs-number">-1</span>,a,b);split_by_rank(b,<span class="hljs-number">1</span>,c,d);T e=val[c];rot=merge(a,merge(c,d));<span class="hljs-keyword">return</span> e;&#125;<span class="hljs-function">T <span class="hljs-title">bef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,d,e;split_by_val(root,x<span class="hljs-number">-1</span>,a,b);T c=findK(a,sz[a]);root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function">T <span class="hljs-title">aft</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b;split_by_val(root,x,a,b);T c=findK(b,<span class="hljs-number">1</span>);root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;&#125;;Treap&lt;<span class="hljs-keyword">int</span>&gt; T;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(n--)&#123;<span class="hljs-keyword">int</span> opt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">switch</span>(opt)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:T.insert(x);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:T.<span class="hljs-built_in">remove</span>(x);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,T.findRank(x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,T.findK(T.root,x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,T.bef(x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,T.aft(x));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="代码version2"><a href="#代码version2" class="headerlink" title="代码version2"></a>代码version2</h3><pre><code class="hljs c++"><span class="hljs-comment">//2020.9.5</span><span class="hljs-comment">//loj104 普通平衡树</span><span class="hljs-comment">//fhq treap</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> val,key,siz; <span class="hljs-comment">//权值,随机权重，子树大小</span><span class="hljs-keyword">int</span> son[<span class="hljs-number">2</span>];<span class="hljs-comment">// 左右儿子　0左1右</span><span class="hljs-comment">//清空该节点，用于删除</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">res</span><span class="hljs-params">()</span></span>&#123; son[<span class="hljs-number">0</span>]=son[<span class="hljs-number">1</span>]=val=key=siz=<span class="hljs-number">0</span>; &#125;&#125;tree[N];<span class="hljs-keyword">int</span> ins;<span class="hljs-keyword">int</span> mem[N],inm; <span class="hljs-comment">//内存回收池</span><span class="hljs-keyword">int</span> root;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].siz=tree[tree[o].son[<span class="hljs-number">0</span>]].siz+tree[tree[o].son[<span class="hljs-number">1</span>]].siz+<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// x,y 两个子树，的且所有的节点的值都小于ｙ的所有节点的值，</span><span class="hljs-comment">// 随机权重都以小根堆的形式存储</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span> x+y; <span class="hljs-comment">//若有一棵树为0则说明该树为空或已合并完成</span><span class="hljs-comment">// 若x的随机值小于y的</span><span class="hljs-comment">// x的右子树和y合并，返回的根作为x的右子树</span><span class="hljs-keyword">if</span>(tree[x].key&lt;tree[y].key)&#123;tree[x].son[<span class="hljs-number">1</span>]=merge(tree[x].son[<span class="hljs-number">1</span>],y);update(x);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则y的左子树和x合并，返回的根作为y的左子树</span>tree[y].son[<span class="hljs-number">0</span>]=merge(x,tree[y].son[<span class="hljs-number">0</span>]);update(y);<span class="hljs-keyword">return</span> y;&#125;&#125;<span class="hljs-comment">//split 有两种写法</span><span class="hljs-comment">//按照权值拆或按照排名拆分</span><span class="hljs-comment">//设定一个基准a,小于等于a的节点全部进入左树,大于a的节点全部进入右树</span><span class="hljs-comment">//按照权值拆分为两棵子树(注意要写引用）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) &#123; x=y=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span>(tree[now].val&lt;=k)&#123;x=now;split1(tree[now].son[<span class="hljs-number">1</span>],k,tree[now].son[<span class="hljs-number">1</span>],y);&#125;<span class="hljs-keyword">else</span> &#123;y=now;split1(tree[now].son[<span class="hljs-number">0</span>],k,x,tree[now].son[<span class="hljs-number">0</span>]);&#125;update(now);&#125;<span class="hljs-comment">//按照排名split</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) &#123; x=y=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125; <span class="hljs-comment">//子树为0,说明无需拆分或者拆分完毕,返回</span><span class="hljs-comment">//update(now);</span><span class="hljs-keyword">if</span>(k&gt;tree[tree[now].son[<span class="hljs-number">0</span>]].siz)&#123; <span class="hljs-comment">// 若子树+1&lt;=k</span>x=now;split2(tree[now].son[<span class="hljs-number">1</span>],k-tree[tree[now].son[<span class="hljs-number">0</span>]].siz<span class="hljs-number">-1</span>,tree[now].son[<span class="hljs-number">1</span>],y);&#125;<span class="hljs-keyword">else</span> &#123;y=now;split2(tree[now].son[<span class="hljs-number">0</span>],k,x,tree[now].son[<span class="hljs-number">0</span>]);&#125;update(now);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-comment">//新建节点</span><span class="hljs-keyword">int</span> u=(inm?mem[inm--]:++ins);tree[u].key=rand();tree[u].val=x;tree[u].siz=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> a,b;split1(root,x,a,b);root=merge(merge(a,u),b);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c,d,e,f;split1(root,x,a,b);split1(a,x<span class="hljs-number">-1</span>,c,d);split2(d,<span class="hljs-number">1</span>,e,f);mem[++inm]=e;tree[e].res();root=merge(merge(c,f),b);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findrnk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c;split1(root,x<span class="hljs-number">-1</span>,a,b);c=tree[a].siz+<span class="hljs-number">1</span>;root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//查询第ｘ小值</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">finnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;rot,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c,d,e;split2(rot,x<span class="hljs-number">-1</span>,a,b);split2(b,<span class="hljs-number">1</span>,c,d);e=tree[c].val;rot=merge(a,merge(c,d));<span class="hljs-keyword">return</span> e;&#125;<span class="hljs-comment">//查询x的前驱</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">las</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c;split1(root,x<span class="hljs-number">-1</span>,a,b);c=finnum(a,tree[a].siz);root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//查询x的后继</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c;split1(root,x,a,b);c=finnum(b,<span class="hljs-number">1</span>);root=merge(a,b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(n--)&#123;<span class="hljs-keyword">int</span> opt=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">switch</span>(opt)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: insert(x);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: delet(x);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,findrnk(x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,finnum(root,x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,las(x));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,nex(x));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="文艺平衡树"><a href="#文艺平衡树" class="headerlink" title="文艺平衡树　"></a>文艺平衡树　</h2><p>解决的是区间问题，感觉和lazy标记的线段树很像．</p><p>参考的资料：　<a href="https://www.cnblogs.com/mjtcn/p/8029680.html" target="_blank" rel="noopener">https://www.cnblogs.com/mjtcn/p/8029680.html</a></p><p>是splay 的模板题，有时间学一下．</p><p><a href="https://loj.ac/problem/105" target="_blank" rel="noopener">题目链接</a></p><pre><code class="hljs c++"><span class="hljs-comment">// ac</span><span class="hljs-comment">// 105 普通平衡树</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">//by Sshwy</span><span class="hljs-keyword">namespace</span> RA&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l*rand()*rand()%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span>&#123;<span class="hljs-keyword">return</span> rnd(R-L+<span class="hljs-number">1</span>)+L;&#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SZ = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">// fhq treap 的模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">Treap</span>&#123;</span><span class="hljs-keyword">int</span> root,tot;<span class="hljs-keyword">int</span> mem[SZ],memp;<span class="hljs-keyword">int</span> lc[SZ],rc[SZ],sz[SZ],tag[SZ];<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rnd[SZ];T val[SZ];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">fill</span>(lc,lc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(rc,rc+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">fill</span>(sz,sz+tot+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);root=tot=<span class="hljs-number">0</span>;&#125;Treap()&#123;root=tot=<span class="hljs-number">0</span>;srand(clock()+time(<span class="hljs-number">0</span>));val[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;sz[u] = sz[lc[u]]+sz[rc[u]]+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(tag[o])&#123;tag[lc[o]]^=<span class="hljs-number">1</span>;tag[rc[o]]^=<span class="hljs-number">1</span>;swap(lc[o],rc[o]);tag[o]^=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> u=memp?mem[memp--]:++tot;val[u]=x, sz[u]=<span class="hljs-number">1</span>, rnd[u]=rand();<span class="hljs-keyword">return</span> u;&#125;<span class="hljs-comment">//x,y两个子树,且所有的节点的值都小于y的所有节点的值</span><span class="hljs-comment">//随机权重以小根堆的形式存储</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//x&lt;y</span><span class="hljs-keyword">if</span>(!x||!y)<span class="hljs-keyword">return</span> x+y;pushdown(x);pushdown(y);<span class="hljs-comment">//if(rand()%(sz[x]+sz[y])&lt;sz[x])return rc[x]=merge(rc[x],y), pushup(x), x;</span><span class="hljs-keyword">if</span>(rnd[x]&lt;rnd[y])<span class="hljs-keyword">return</span> rc[x]=merge(rc[x],y), pushup(x), x;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> lc[y]=merge(x,lc[y]), pushup(y), y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> left_size,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!u)<span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();pushdown(u);<span class="hljs-keyword">if</span>(sz[lc[u]]+<span class="hljs-number">1</span>&lt;=left_size)x=u,split(rc[u],left_size-sz[lc[u]]<span class="hljs-number">-1</span>,rc[u],y);<span class="hljs-keyword">else</span> y=u,split(lc[u],left_size,x,lc[u]);pushup(u);&#125;<span class="hljs-comment">//按住权值拆分为两颗子树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">const</span> T k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();pushdown(now);<span class="hljs-keyword">if</span>(val[now]&lt;=k) x=now,split_by_val(rc[now],k,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_val(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-comment">//按照排名拆分成两颗子树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split_by_rank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<span class="hljs-keyword">if</span>(!now) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>();pushdown(now);<span class="hljs-keyword">if</span>(sz[lc[now]]+<span class="hljs-number">1</span>&lt;=k) x=now,split_by_rank(rc[now],k-sz[lc[now]]<span class="hljs-number">-1</span>,rc[now],y);<span class="hljs-keyword">else</span> y=now,split_by_rank(lc[now],k,x,lc[now]);pushup(now);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T v)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,u=memp?mem[memp--]:++tot;val[u]=v;sz[u]=<span class="hljs-number">1</span>;rnd[u]=rand();split_by_val(root,v,a,b);root=merge(merge(a,u),b);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">int</span> a,b,c,d;split_by_rank(root,r,a,b);split_by_rank(a,l<span class="hljs-number">-1</span>,c,d);tag[d]^=<span class="hljs-number">1</span>;root=merge(merge(c,d),b);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(!o) <span class="hljs-keyword">return</span>;pushdown(o);<span class="hljs-built_in">print</span>(lc[o]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,val[o]);<span class="hljs-built_in">print</span>(rc[o]);&#125;&#125;;Treap&lt;<span class="hljs-keyword">int</span>&gt; T;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n) T.insert(i);<span class="hljs-keyword">while</span>(m--)&#123; <span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();T.reverse(a,b);&#125;T.<span class="hljs-built_in">print</span>(T.root);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>模板留存</tag>
      
      <tag>fhq treap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探treap1</title>
    <link href="/2020/08/28/%E5%88%9D%E6%8E%A2treap1/"/>
    <url>/2020/08/28/%E5%88%9D%E6%8E%A2treap1/</url>
    
    <content type="html"><![CDATA[<p>初探treap, 走入平衡树大家族．</p><a id="more"></a><p>平衡树大家族可还行．</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/guoshaoyang/p/11300886.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoshaoyang/p/11300886.html</a></p><p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/85037548" target="_blank" rel="noopener">https://blog.csdn.net/yandaoqiusheng/article/details/85037548</a></p><p><a href="https://blog.csdn.net/chenxiaoran666/article/details/81391565" target="_blank" rel="noopener">https://blog.csdn.net/chenxiaoran666/article/details/81391565</a></p><h2 id="普通平衡树"><a href="#普通平衡树" class="headerlink" title="普通平衡树"></a>普通平衡树</h2><p><a href="https://loj.ac/problem/104" target="_blank" rel="noopener">loj 题目链接</a></p><p><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">洛谷题目链接</a></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="　我的代码"></a>　我的代码</h2><p>基本上是上述一个参考资料简单修改了一点点，以及加上了很多注释．</p><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">编号题目状态分数总时间内存代码 / 答案文件提交者提交时间</span><span class="hljs-comment">#919994#104. 普通平衡树  Accepted100445 ms1284 KC++ 11 / 2.6 Krobot2020-08-28 8:48:23</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> siz[N],key[N],cnt[N],rd[N],son[N][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> sz,rt;<span class="hljs-comment">// 要根据具体题目数据范围调整</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-comment">// 用自带的rand 　在洛谷上ac了</span><span class="hljs-comment">// 用这个手写的rand 有一个数据TLE了</span><span class="hljs-comment">/*</span><span class="hljs-comment">unsigned int seed;</span><span class="hljs-comment">int rand()&#123;</span><span class="hljs-comment">return seed=(int) seed * 482711LL % 2147483647;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;siz[x]=siz[son[x][<span class="hljs-number">0</span>]]+siz[son[x][<span class="hljs-number">1</span>]]+cnt[x];&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> o=son[x][y^<span class="hljs-number">1</span>];son[x][y^<span class="hljs-number">1</span>]=son[o][y];son[o][y]=x;pushup(x);pushup(o);x=o;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p,<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-keyword">if</span>(!p)&#123; p=++sz; siz[p]=cnt[p]=<span class="hljs-number">1</span>; key[p]=x; rd[p]=rand(); <span class="hljs-keyword">return</span>; &#125; <span class="hljs-keyword">if</span>(key[p]==x)&#123; cnt[p]++; siz[p]++; <span class="hljs-keyword">return</span>; &#125;<span class="hljs-keyword">int</span> d=(x&gt;key[p]);insert(son[p][d],x);<span class="hljs-keyword">if</span>(rd[p]&lt;rd[son[p][d]]) rotate(p,d^<span class="hljs-number">1</span>);pushup(p);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(x!=key[p])  delet(son[p][x&gt;key[p]],x);<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(!son[p][<span class="hljs-number">0</span>]&amp;&amp;!son[p][<span class="hljs-number">1</span>])&#123;cnt[p]--; siz[p]--; <span class="hljs-keyword">if</span>(cnt[p]==<span class="hljs-number">0</span>) p=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son[p][<span class="hljs-number">0</span>]&amp;&amp;!son[p][<span class="hljs-number">1</span>])&#123;rotate(p,<span class="hljs-number">1</span>); delet(son[p][<span class="hljs-number">1</span>],x);   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!son[p][<span class="hljs-number">0</span>]&amp;&amp;son[p][<span class="hljs-number">1</span>])&#123;rotate(p,<span class="hljs-number">0</span>); delet(son[p][<span class="hljs-number">0</span>],x);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">int</span> d=rd[son[p][<span class="hljs-number">0</span>]]&gt;rd[son[p][<span class="hljs-number">1</span>]];rotate(p,d); delet(son[p][d],x);&#125;&#125;pushup(p);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-comment">// 空结点,直接返回</span><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// x=key[p],返回左子树节点数+1</span><span class="hljs-keyword">if</span>(key[p]==x) <span class="hljs-keyword">return</span> siz[son[p][<span class="hljs-number">0</span>]]+<span class="hljs-number">1</span>;<span class="hljs-comment">// key[p]&lt;x) x位于右子树，左子树个数+结点个数+x在右子树的位置</span><span class="hljs-keyword">if</span>(key[p]&lt;x) <span class="hljs-keyword">return</span> siz[son[p][<span class="hljs-number">0</span>]]+cnt[p]+get_rank(son[p][<span class="hljs-number">1</span>],x);<span class="hljs-comment">//if(key[p]&gt;x) x位于左子树,直接向左边递归</span><span class="hljs-keyword">return</span> get_rank(son[p][<span class="hljs-number">0</span>],x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(siz[son[p][<span class="hljs-number">0</span>]]&gt;=x)<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(son[p][<span class="hljs-number">0</span>],x);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(siz[son[p][<span class="hljs-number">0</span>]]+cnt[p]&lt;x)<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(son[p][<span class="hljs-number">1</span>],x-cnt[p]-siz[son[p][<span class="hljs-number">0</span>]]);<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> key[p];&#125;<span class="hljs-comment">// 前驱定义为小于ｘ,且最大的数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> -INF;<span class="hljs-keyword">if</span>(key[p]&gt;=x) <span class="hljs-keyword">return</span> pre(son[p][<span class="hljs-number">0</span>],x);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(key[p],pre(son[p][<span class="hljs-number">1</span>],x));&#125;<span class="hljs-comment">// 后继定义为大于ｘ,且最小的数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> INF;<span class="hljs-keyword">if</span>(key[p]&lt;=x) <span class="hljs-keyword">return</span> suf(son[p][<span class="hljs-number">1</span>],x);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(key[p],suf(son[p][<span class="hljs-number">0</span>],x));&#125;main()&#123;<span class="hljs-keyword">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--)&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">switch</span>(x)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: insert(rt,y); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: delet(rt,y); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,get_rank(rt,y)); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">find</span>(rt,y)); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,pre(rt,y)); <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,suf(rt,y)); <span class="hljs-keyword">break</span>; &#125;&#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>模板留存</tag>
      
      <tag>treap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unRootedTrie</title>
    <link href="/2020/08/26/unRootedTrie/"/>
    <url>/2020/08/26/unRootedTrie/</url>
    
    <content type="html"><![CDATA[<p>若你能听见岁月的拨弦，</p><p>依然能感觉你从未消失过．</p><a id="more"></a><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370529" target="_blank" rel="noopener">zoj题目地址</a></p><p><a href="https://vjudge.net/contest/315289#overview" target="_blank" rel="noopener">2019陕西省赛vjudge</a></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><pre><code class="hljs c++"><span class="hljs-comment">//ResultTime(ms)Memory(KB)</span><span class="hljs-comment">//0Accepted44021504 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span> <span class="hljs-keyword">int</span> to,nxt;<span class="hljs-keyword">char</span> ch; &#125; edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv]; <span class="hljs-keyword">int</span> top;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to,<span class="hljs-keyword">char</span> ch)</span></span>&#123;edge[top].to=to;edge[top].ch=ch;edge[top].nxt=head[from];head[from]=top++;&#125;<span class="hljs-keyword">int</span> pos[maxv],sz[maxv],f[maxv];<span class="hljs-keyword">char</span> fColor[maxv];<span class="hljs-keyword">int</span> cnt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;pos[u]=++cnt;sz[u]=<span class="hljs-number">1</span>;f[u]=fa;fColor[u]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> to=edge[i].to;<span class="hljs-keyword">char</span> ch=edge[i].ch;<span class="hljs-keyword">if</span>(to==fa) &#123;fColor[u]=ch;<span class="hljs-keyword">continue</span>;&#125;dfs(to,u);sz[u]+=sz[to];&#125;&#125;<span class="hljs-keyword">int</span> hav[maxv][<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> twoColor[maxv];<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;val[l]+=o;val[r+<span class="hljs-number">1</span>]-=o;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;cnt=top=<span class="hljs-number">0</span>;n=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n) &#123;head[i]=<span class="hljs-number">-1</span>;inc(j,<span class="hljs-number">0</span>,<span class="hljs-number">30</span>) hav[i][j]=<span class="hljs-number">0</span>;val[i]=<span class="hljs-number">0</span>;twoColor[i]=<span class="hljs-number">-1</span>;&#125;inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> u=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> v=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">char</span> ch; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>,&amp;ch);addedge(u,v,ch);addedge(v,u,ch);&#125;<span class="hljs-keyword">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];~j;j=edge[j].nxt)&#123;<span class="hljs-keyword">char</span> ch=edge[j].ch;hav[i][ch-<span class="hljs-string">'a'</span>]++;&#125;<span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>,cnt3=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch=<span class="hljs-string">'a'</span>;ch&lt;=<span class="hljs-string">'z'</span>;ch++)&#123;<span class="hljs-keyword">if</span>(hav[i][ch-<span class="hljs-string">'a'</span>]==<span class="hljs-number">2</span>) twoColor[i]=ch,cnt2++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hav[i][ch-<span class="hljs-string">'a'</span>]&gt;=<span class="hljs-number">3</span>) cnt3++;&#125;<span class="hljs-keyword">if</span>(cnt3&gt;=<span class="hljs-number">1</span>) ok=<span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span>(cnt2&gt;<span class="hljs-number">1</span>) ok=<span class="hljs-literal">false</span>; &#125;<span class="hljs-keyword">if</span>(ok==<span class="hljs-literal">false</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>); <span class="hljs-keyword">continue</span>; &#125;dfs(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">if</span>(twoColor[i]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;update(pos[i],pos[i],<span class="hljs-number">-1</span>);<span class="hljs-keyword">int</span> tc=twoColor[i];<span class="hljs-keyword">int</span> fc=fColor[i];<span class="hljs-keyword">if</span>(fc==<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];~j;j=edge[j].nxt)&#123;<span class="hljs-keyword">int</span> to=edge[j].to;<span class="hljs-keyword">char</span> ch=edge[j].ch;<span class="hljs-keyword">if</span>(to==f[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(ch!=tc)&#123;<span class="hljs-keyword">int</span> l=pos[to];<span class="hljs-keyword">int</span> r=pos[to]+sz[to]<span class="hljs-number">-1</span>;update(l,r,<span class="hljs-number">-1</span>);&#125;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fc==tc)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];~j;j=edge[j].nxt)&#123;<span class="hljs-keyword">int</span> to=edge[j].to;<span class="hljs-keyword">char</span> ch=edge[j].ch;<span class="hljs-keyword">if</span>(to==f[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(ch==fc) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">int</span> l=pos[to];<span class="hljs-keyword">int</span> r=pos[to]+sz[to]<span class="hljs-number">-1</span>;update(l,r,<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;update(<span class="hljs-number">1</span>,n,<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];~j;j=edge[j].nxt)&#123;<span class="hljs-keyword">int</span> to=edge[j].to;<span class="hljs-keyword">char</span> ch=edge[j].ch;<span class="hljs-keyword">if</span>(to==f[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span>(ch==tc) &#123;<span class="hljs-keyword">int</span> l=pos[to];<span class="hljs-keyword">int</span> r=pos[to]+sz[to]<span class="hljs-number">-1</span>;update(l,r,<span class="hljs-number">1</span>);&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++) val[i]+=val[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(val[i]&gt;=<span class="hljs-number">0</span>) ans++;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>2019陕西省赛</tag>
      
      <tag>树上信息统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探树链剖分3</title>
    <link href="/2020/08/26/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%863/"/>
    <url>/2020/08/26/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%863/</url>
    
    <content type="html"><![CDATA[<p>SDOI2014 旅行</p><p>动态线段树．</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://loj.ac/problem/2195" target="_blank" rel="noopener">题目链接</a>　</p><h2 id="调试心得"><a href="#调试心得" class="headerlink" title="调试心得"></a>调试心得</h2><p>稳定心态，一定能搞对的　：｜</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-comment">//very happy </span><span class="hljs-comment">//get ac :)</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">// notice !!!</span><span class="hljs-comment">// 初始化 maxv 不同的题目,可能会有所变化</span><span class="hljs-comment">// 多组数据时,记得初始化cnt=0 </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span> <span class="hljs-keyword">int</span> to,nxt; &#125;edge[maxv*<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> head[maxv],tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123; edge[tot].to=to; edge[tot].nxt=head[from]; head[from]=tot++; &#125;<span class="hljs-keyword">int</span> cnt,f[maxv],d[maxv],sz[maxv],son[maxv],rk[maxv],top[maxv],pos[maxv];<span class="hljs-comment">// get f d sz  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span>&#123;  <span class="hljs-comment">// 当前节点、父亲节点、层次深度  dfs1(root,0,1)</span>f[u]=fa,d[u]=depth,sz[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123; <span class="hljs-keyword">int</span> v=edge[i].to; <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;sz[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>); <span class="hljs-keyword">if</span>(sz[v]&gt;maxson)&#123; maxson=sz[v]; son[u]=v; &#125; &#125; <span class="hljs-keyword">return</span> sz[u]; &#125;<span class="hljs-comment">// get rk top pos   cnt=0; dfs2(root,root);</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> </span>&#123;<span class="hljs-comment">// 当前节点，重链顶端</span>top[u]=t; pos[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>; dfs2(son[u],t); <span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123; <span class="hljs-keyword">int</span> v=edge[i].to; <span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u]) dfs2(v,v); &#125; &#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//动态线段树的结点个数q*log N</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxTree=N&lt;&lt;<span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> rt[N],num=<span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls(x) tree[x].ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs(x) tree[x].rs</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mx(x) tree[x].mx</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sum(x) tree[x].sum</span><span class="hljs-keyword">int</span> ls,rs,mx,sum;&#125;tree[maxTree];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;sum(o)=sum(ls(o))+sum(rs(o));mx(o)=<span class="hljs-built_in">max</span>(mx(ls(o)),mx(rs(o)));<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> val,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;o)</span></span>&#123;<span class="hljs-keyword">if</span>(!o) o=++num;<span class="hljs-keyword">if</span>(l==r)&#123;sum(o)=mx(o)=val;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=m)  insert(p,val,l,m,ls(o));<span class="hljs-keyword">else</span> insert(p,val,m+<span class="hljs-number">1</span>,r,rs(o));pushup(o);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;o)</span></span>&#123;<span class="hljs-keyword">if</span>(!o) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(l==r)&#123;sum(o)=mx(o)=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=m) <span class="hljs-built_in">remove</span>(p,l,m,ls(o));<span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(p,m+<span class="hljs-number">1</span>,r,rs(o));pushup(o);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> sum(o);<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m)ans+=getsum(ql,qr,l,m,ls(o));<span class="hljs-keyword">if</span>(qr&gt;m)ans+=getsum(ql,qr,m+<span class="hljs-number">1</span>,r,rs(o));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r)<span class="hljs-keyword">return</span> mx(o);<span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=mid) ans=<span class="hljs-built_in">max</span>(ans,getmax(ql,qr,l,mid,ls(o)));<span class="hljs-keyword">if</span>(qr&gt;mid)ans=<span class="hljs-built_in">max</span>(ans,getmax(ql,qr,mid+<span class="hljs-number">1</span>,r,rs(o)));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">int</span> val[maxv],c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_color</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-built_in">remove</span>(pos[x],<span class="hljs-number">1</span>,n,rt[c[x]]);c[x]=y;insert(pos[x],val[x],<span class="hljs-number">1</span>,n,rt[y]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_weight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;val[x]=y;insert(pos[x],y,<span class="hljs-number">1</span>,n,rt[c[x]]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query_sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,col=c[x];<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);<span class="hljs-comment">//ans=max(ans,getmax(1,n,rt[col],id[x],id[y]));</span>ans+=getsum(pos[top[x]],pos[x],<span class="hljs-number">1</span>,n,rt[col]);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y])swap(x,y);ans+=getsum(pos[x],pos[y],<span class="hljs-number">1</span>,n,rt[col]);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,col=c[x];<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,getmax(pos[top[x]],pos[x],<span class="hljs-number">1</span>,n,rt[col]));x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y])swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,getmax(pos[x],pos[y],<span class="hljs-number">1</span>,n,rt[col]));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q); inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,val+i,c+i);tot=<span class="hljs-number">0</span>;mst(head,<span class="hljs-number">-1</span>);inc(i,<span class="hljs-number">2</span>,n)&#123; <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);addedge(x,y);addedge(y,x);&#125;cnt=<span class="hljs-number">0</span>;dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);inc(i,<span class="hljs-number">1</span>,n) insert(pos[i],val[i],<span class="hljs-number">1</span>,n,rt[c[i]]);<span class="hljs-keyword">while</span>(q--)&#123; <span class="hljs-keyword">char</span> ch[<span class="hljs-number">10</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %s"</span>,ch);<span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);<span class="hljs-keyword">char</span> op=ch[<span class="hljs-number">1</span>];<span class="hljs-keyword">switch</span>(op)&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>: change_color(x,y);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'W'</span>: change_weight(x,y);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'S'</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query_sum(x,y));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'M'</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query_max(x,y));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="带内存回收的代码"><a href="#带内存回收的代码" class="headerlink" title="带内存回收的代码"></a>带内存回收的代码</h2><p><del>2020.8.44 UDP</del><br>上述的代码，删除的节点的空间是直接放弃的<br>但是其实是可以回收利用的：）</p><p>参考了如下资料<br><a href="https://www.luogu.com.cn/blog/ix-35/solution-p6012" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/ix-35/solution-p6012</a></p><pre><code class="hljs c++"><span class="hljs-comment">//very happy </span><span class="hljs-comment">//get ac :)</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">// notice !!!</span><span class="hljs-comment">// 初始化 maxv 不同的题目,可能会有所变化</span><span class="hljs-comment">// 多组数据时,记得初始化cnt=0 </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span> <span class="hljs-keyword">int</span> to,nxt; &#125;edge[maxv*<span class="hljs-number">2</span>]; <span class="hljs-keyword">int</span> head[maxv],tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123; edge[tot].to=to; edge[tot].nxt=head[from]; head[from]=tot++; &#125;<span class="hljs-keyword">int</span> cnt,f[maxv],d[maxv],sz[maxv],son[maxv],rk[maxv],top[maxv],pos[maxv];<span class="hljs-comment">// get f d sz  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span>&#123;  <span class="hljs-comment">// 当前节点、父亲节点、层次深度  dfs1(root,0,1)</span>f[u]=fa,d[u]=depth,sz[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123; <span class="hljs-keyword">int</span> v=edge[i].to; <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;sz[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>); <span class="hljs-keyword">if</span>(sz[v]&gt;maxson)&#123; maxson=sz[v]; son[u]=v; &#125; &#125; <span class="hljs-keyword">return</span> sz[u]; &#125;<span class="hljs-comment">// get rk top pos   cnt=0; dfs2(root,root);</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> </span>&#123;<span class="hljs-comment">// 当前节点，重链顶端</span>top[u]=t; pos[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>; dfs2(son[u],t); <span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123; <span class="hljs-keyword">int</span> v=edge[i].to; <span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u]) dfs2(v,v); &#125; &#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//动态线段树的结点个数q*log N</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxTree=N&lt;&lt;<span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> rt[N],num=<span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls(x) tree[x].ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs(x) tree[x].rs</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mx(x) tree[x].mx</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sum(x) tree[x].sum</span><span class="hljs-keyword">int</span> ls,rs,mx,sum;&#125;tree[maxTree];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;sum(o)=sum(ls(o))+sum(rs(o));mx(o)=<span class="hljs-built_in">max</span>(mx(ls(o)),mx(rs(o)));<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-comment">//带内存回收的版本</span><span class="hljs-comment">//如果多组数据记得初始化ins=0</span><span class="hljs-keyword">int</span> mem[maxv];<span class="hljs-keyword">int</span> ins;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">///return ++num;</span><span class="hljs-keyword">return</span> ins?mem[ins--]:++num;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delnode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p)</span></span>&#123;mem[++ins]=p;<span class="hljs-comment">//cout&lt;&lt;"oh "&lt;&lt;ins&lt;&lt;endl;</span>ls(p)=rs(p)=mx(p)=sum(p)=<span class="hljs-number">0</span>;p=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> val,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;o)</span></span>&#123;<span class="hljs-keyword">if</span>(!o) o=newnode();<span class="hljs-keyword">if</span>(l==r)&#123;sum(o)=mx(o)=val;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=m)  insert(p,val,l,m,ls(o));<span class="hljs-keyword">else</span> insert(p,val,m+<span class="hljs-number">1</span>,r,rs(o));pushup(o);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;o)</span></span>&#123;<span class="hljs-keyword">if</span>(!o) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(l==r)&#123;delnode(o);o=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=m) <span class="hljs-built_in">remove</span>(p,l,m,ls(o));<span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(p,m+<span class="hljs-number">1</span>,r,rs(o));pushup(o);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> sum(o);<span class="hljs-keyword">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m)ans+=getsum(ql,qr,l,m,ls(o));<span class="hljs-keyword">if</span>(qr&gt;m)ans+=getsum(ql,qr,m+<span class="hljs-number">1</span>,r,rs(o));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;qr&gt;=r)<span class="hljs-keyword">return</span> mx(o);<span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=mid) ans=<span class="hljs-built_in">max</span>(ans,getmax(ql,qr,l,mid,ls(o)));<span class="hljs-keyword">if</span>(qr&gt;mid)ans=<span class="hljs-built_in">max</span>(ans,getmax(ql,qr,mid+<span class="hljs-number">1</span>,r,rs(o)));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">int</span> val[maxv],c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_color</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-built_in">remove</span>(pos[x],<span class="hljs-number">1</span>,n,rt[c[x]]);c[x]=y;insert(pos[x],val[x],<span class="hljs-number">1</span>,n,rt[y]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_weight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;val[x]=y;insert(pos[x],y,<span class="hljs-number">1</span>,n,rt[c[x]]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query_sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,col=c[x];<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);<span class="hljs-comment">//ans=max(ans,getmax(1,n,rt[col],id[x],id[y]));</span>ans+=getsum(pos[top[x]],pos[x],<span class="hljs-number">1</span>,n,rt[col]);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y])swap(x,y);ans+=getsum(pos[x],pos[y],<span class="hljs-number">1</span>,n,rt[col]);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,col=c[x];<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,getmax(pos[top[x]],pos[x],<span class="hljs-number">1</span>,n,rt[col]));x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y])swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,getmax(pos[x],pos[y],<span class="hljs-number">1</span>,n,rt[col]));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q); inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,val+i,c+i);tot=<span class="hljs-number">0</span>;mst(head,<span class="hljs-number">-1</span>);inc(i,<span class="hljs-number">2</span>,n)&#123; <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);addedge(x,y);addedge(y,x);&#125;cnt=<span class="hljs-number">0</span>;dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);inc(i,<span class="hljs-number">1</span>,n) insert(pos[i],val[i],<span class="hljs-number">1</span>,n,rt[c[i]]);<span class="hljs-keyword">while</span>(q--)&#123; <span class="hljs-keyword">char</span> ch[<span class="hljs-number">10</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %s"</span>,ch);<span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);<span class="hljs-keyword">char</span> op=ch[<span class="hljs-number">1</span>];<span class="hljs-keyword">switch</span>(op)&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>: change_color(x,y);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'W'</span>: change_weight(x,y);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'S'</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query_sum(x,y));<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'M'</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query_max(x,y));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://loj.ac/submission/906239" target="_blank" rel="noopener">https://loj.ac/submission/906239</a></p><p><a href="https://www.cnblogs.com/fusiwei/p/12628596.html" target="_blank" rel="noopener">https://www.cnblogs.com/fusiwei/p/12628596.html</a></p><p>可能的应用<br><a href="https://www.dazhuanlan.com/2019/12/12/5df12764defa5/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/12/5df12764defa5/</a></p><p>线段树合并<br><a href="https://blog.csdn.net/weixin_44178736/article/details/100097996" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44178736/article/details/100097996</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
      <tag>模板留存</tag>
      
      <tag>树链剖分</tag>
      
      <tag>动态线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探树链剖分2-SDOI2011染色</title>
    <link href="/2020/08/25/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%862-SDOI2011%E6%9F%93%E8%89%B2/"/>
    <url>/2020/08/25/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%862-SDOI2011%E6%9F%93%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<p>SDOI2011染色</p><p>这多标记线段树真的是调试老费劲了：｜</p><p>感觉最好的方式还是直接写对 ．</p><a id="more"></a><h2 id="题目大意和思路分析"><a href="#题目大意和思路分析" class="headerlink" title="题目大意和思路分析"></a>题目大意和思路分析</h2><p><a href="https://www.luogu.com.cn/problem/P2486" target="_blank" rel="noopener">题目链接</a> 　</p><p>题意直接看题吧，不是很长，而且是中文的．</p><p>树链剖分之后需要用一个多标记线段树解决．</p><h3 id="难点一"><a href="#难点一" class="headerlink" title="难点一"></a>难点一</h3><p>这个线段树　需要可以<code>区间修改</code>，同时<code>查询区间中有多少段颜色</code>.</p><p>为了达成这个目标，需要 维护如下信息：</p><p>区间颜色的段数(num)，</p><p>区间最左边的颜色(lc)，</p><p>区间最右边的颜色(rc).</p><p>区间是否被覆盖的标记(mark)．</p><p>还好这几个标记的关系不是非常难以维护，pushup和pushdown函数都比较好写.</p><h3 id="难点二"><a href="#难点二" class="headerlink" title="难点二"></a>难点二</h3><p>利用LCA的框架，链条之间的颜色可能重复，要想办法减去多余的贡献．</p><h2 id="调试心得"><a href="#调试心得" class="headerlink" title="调试心得"></a>调试心得</h2><p>涉及到树的数据结构调试，往往非常复杂．</p><p>gdb和大力printf 都是可选方案（其实都非常繁琐），个人认为gdb在处理线性程序时更有优势．</p><p>一方面可以造一些特殊数据，比如一条链，二叉树等等．</p><p>另一方面可以把数据结构模板模块化，在容易问题的地方找bug，比如线段树的pushup和pushdown函数．</p><h2 id="函数式编程风的代码"><a href="#函数式编程风的代码" class="headerlink" title="函数式编程风的代码"></a>函数式编程风的代码</h2><p>其实就是利用define 压缩线段树部分的代码，感觉写的比较顺手：）</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span> <span class="hljs-keyword">int</span> to,nxt; &#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv],tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123; edge[tot].to=to; edge[tot].nxt=head[from]; head[from]=tot++; &#125;<span class="hljs-keyword">int</span> cnt,f[maxv],d[maxv],sz[maxv],son[maxv],rk[maxv],top[maxv],pos[maxv];<span class="hljs-comment">// get sz son f d      dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span>&#123; <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span>f[u]=fa,d[u]=depth,sz[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;sz[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(sz[v]&gt;maxson)&#123;maxson=sz[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> sz[u];&#125;<span class="hljs-comment">// get rk top pos   dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> </span>&#123;<span class="hljs-comment">// 当前节点，重链顶端</span>top[u]=t;pos[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> num,mark,lc,rc,l,r;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lc(x) tree[x].lc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rc(x) tree[x].rc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> num(x) tree[x].num</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mark(x) tree[x].mark</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> l(x) tree[o].l</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> r(x) tree[o].r</span>&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;lc(o)=lc(ls);rc(o)=rc(rs);num(o)=num(ls)+num(rs);<span class="hljs-keyword">if</span>(rc(ls)==lc(rs)) num(o)--;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(mark(o)==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;num(ls)=num(rs)=<span class="hljs-number">1</span>;mark(ls)=mark(rs)=mark(o);lc(ls)=lc(rs)=mark(o);rc(ls)=rc(rs)=mark(o);mark(o)=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;l(o)=l,r(o)=r,mark(o)=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;lc(o)=rc(o)=c[rk[l]];num(o)=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l(o) &amp;&amp; r(o)&lt;=qr)&#123;num(o)=<span class="hljs-number">1</span>;mark(o)=lc(o)=rc(o)=v;<span class="hljs-keyword">return</span>;&#125;pushdown(o);<span class="hljs-keyword">int</span> m=(l(o)+r(o))&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,v,ls);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,v,rs);pushup(o);&#125;<span class="hljs-function">Tree <span class="hljs-title">merge</span><span class="hljs-params">(Tree fi,Tree se)</span></span>&#123;Tree ans;ans.num=fi.num+se.num;ans.lc=fi.lc;ans.rc=se.rc;<span class="hljs-keyword">if</span>(fi.rc==se.lc) ans.num--;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">Tree <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l(o) &amp;&amp; r(o)&lt;=qr) <span class="hljs-keyword">return</span> tree[o];pushdown(o);<span class="hljs-keyword">int</span> m=l(o)+r(o)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(qr&lt;=m) <span class="hljs-keyword">return</span> query(ql,qr,ls);<span class="hljs-keyword">if</span>(ql&gt;m) <span class="hljs-keyword">return</span> query(ql,qr,rs);<span class="hljs-keyword">return</span> merge(query(ql,qr,ls),query(ql,qr,rs));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> c)</span></span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);update(pos[top[x]],pos[x],c,<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);update(pos[x],pos[y],c,<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,ql=<span class="hljs-number">0</span>,qr=<span class="hljs-number">0</span>; Tree t;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y),swap(ql,qr);t=query(pos[top[x]],pos[x],<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(t.rc==ql) --t.num;res+=t.num;ql=t.lc;x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y),swap(ql,qr);t=query(pos[x],pos[y],<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ql==t.lc) t.num--;<span class="hljs-keyword">if</span>(qr==t.rc) t.num--;<span class="hljs-keyword">return</span> t.num+res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);tot=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) head[i]=<span class="hljs-number">-1</span>,<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,c+i);inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> u,v;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;u,&amp;v);addedge(u,v); addedge(v,u);&#125;cnt=<span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>; dfs1(r,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); dfs2(r,r); build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-keyword">char</span> op;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>,&amp;op);<span class="hljs-keyword">if</span>(op==<span class="hljs-string">'C'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);paint(a,b,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">'Q'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,qnum(a,b));&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="普通代码"><a href="#普通代码" class="headerlink" title="普通代码"></a>普通代码</h2><pre><code class="hljs c++"><span class="hljs-comment">//https://www.luogu.com.cn/problem/P2486 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">bool</span> show=<span class="hljs-literal">false</span>;<span class="hljs-comment">// --------------------------------------------------------</span><span class="hljs-comment">// notice : 记得更改maxv的数量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> f[maxv];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxv];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> sz[maxv]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxv];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxv];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxv];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> pos[maxv];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-comment">// get sz son f d </span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;sz[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;sz[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(sz[v]&gt;maxson)&#123;maxson=sz[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> sz[u];&#125;<span class="hljs-comment">// get rk top pos</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;pos[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> val;<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">int</span> mark;<span class="hljs-keyword">int</span> lc,rc; <span class="hljs-comment">//区间最左的颜色，区间最右的颜色</span><span class="hljs-keyword">int</span> l,r;&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].lc=tree[ls].lc;tree[o].rc=tree[rs].rc;tree[o].num=tree[ls].num+tree[rs].num;<span class="hljs-keyword">if</span>(tree[ls].rc==tree[rs].lc) tree[o].num--;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o].mark==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;tree[ls].val=tree[rs].val=tree[o].mark;tree[ls].num=tree[rs].num=<span class="hljs-number">1</span>;tree[ls].mark=tree[rs].mark=tree[o].mark;tree[ls].lc=tree[rs].lc=tree[o].mark;tree[ls].rc=tree[rs].rc=tree[o].mark;tree[o].mark=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].l=l;tree[o].r=r;tree[o].mark=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;tree[o].val=c[rk[l]];<span class="hljs-comment">//cout&lt;&lt;c[rk[l]]&lt;&lt;" ";</span>tree[o].num=<span class="hljs-number">1</span>;tree[o].lc=tree[o].val;tree[o].rc=tree[o].val;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tree[o].val=v;tree[o].num=<span class="hljs-number">1</span>;tree[o].mark=v;tree[o].lc=v;tree[o].rc=v;<span class="hljs-keyword">return</span>;&#125;pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,v,ls);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,v,rs);pushup(o);&#125;<span class="hljs-function">Tree <span class="hljs-title">merge</span><span class="hljs-params">(Tree fi,Tree se)</span></span>&#123;Tree ans;ans.num=fi.num+se.num;ans.lc=fi.lc;    <span class="hljs-comment">//notice 调试了这么长时间</span>    <span class="hljs-comment">//错误原因是这一行的se写错了，写成了fi</span>ans.rc=se.rc;<span class="hljs-keyword">if</span>(fi.rc==se.lc) ans.num--;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">Tree <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> tree[o];pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(qr&lt;=m) <span class="hljs-keyword">return</span> query(ql,qr,ls);<span class="hljs-keyword">if</span>(ql&gt;m) <span class="hljs-keyword">return</span> query(ql,qr,rs);<span class="hljs-keyword">return</span> merge(query(ql,qr,ls),query(ql,qr,rs));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> c)</span></span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);update(pos[top[x]],pos[x],c,<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);update(pos[x],pos[y],c,<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;Tree t;<span class="hljs-keyword">int</span> ql=<span class="hljs-number">0</span>,qr=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y),swap(ql,qr);<span class="hljs-comment">//cout&lt;&lt;pos[top[x]]&lt;&lt;" "&lt;&lt;pos[x]&lt;&lt;endl;</span>t=query(pos[top[x]],pos[x],<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(t.rc==ql) --t.num;res+=t.num;ql=t.lc;x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y),swap(ql,qr);t=query(pos[x],pos[y],<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(ql==t.lc) t.num--;<span class="hljs-keyword">if</span>(qr==t.rc) t.num--;<span class="hljs-keyword">return</span> t.num+res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);head[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;tot=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,c+i);head[i]=<span class="hljs-number">-1</span>;&#125;inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> u=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> v=<span class="hljs-built_in">read</span>();addedge(u,v);addedge(v,u);&#125;<span class="hljs-comment">//---------------------------------------------------</span>cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;dfs1(r,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(r,r);<span class="hljs-comment">//---------------------------------------------------</span>build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-keyword">char</span> op;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>,&amp;op);<span class="hljs-keyword">if</span>(op==<span class="hljs-string">'C'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);paint(a,b,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">'Q'</span>)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,qnum(a,b));&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="调试对拍程序"><a href="#调试对拍程序" class="headerlink" title="调试对拍程序"></a>调试对拍程序</h2><p>实际上并不是这么对拍找错误数据调试出来的，而是我自己观察出了问题　：｜</p><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><pre><code class="hljs bash">cnt=0 <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>./c &gt; data.in./a&lt;data.in&gt; a.out./b&lt;data.in&gt; b.outdiff a.out b.out<span class="hljs-keyword">if</span> [ $? -ne 0 ] ;<span class="hljs-keyword">then</span> <span class="hljs-built_in">break</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$cnt</span><span class="hljs-built_in">let</span> cnt=cnt+1<span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h3 id="调试的线段树程序"><a href="#调试的线段树程序" class="headerlink" title="调试的线段树程序"></a>调试的线段树程序</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> val;<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">int</span> mark;<span class="hljs-keyword">int</span> lc,rc; <span class="hljs-comment">//区间最左的颜色，区间最右的颜色</span><span class="hljs-keyword">int</span> l,r;&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].lc=tree[ls].lc;tree[o].rc=tree[rs].rc;tree[o].num=tree[ls].num+tree[rs].num;<span class="hljs-keyword">if</span>(tree[ls].rc==tree[rs].lc) tree[o].num--;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o].mark==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;tree[ls].val=tree[rs].val=tree[o].mark;tree[ls].num=tree[rs].num=<span class="hljs-number">1</span>;tree[ls].mark=tree[rs].mark=tree[o].mark;tree[ls].lc=tree[rs].lc=tree[o].mark;tree[ls].rc=tree[rs].rc=tree[o].mark;tree[o].mark=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].l=l;tree[o].r=r;tree[o].mark=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;tree[o].val=c[l];<span class="hljs-comment">//cout&lt;&lt;c[l]&lt;&lt;endl;</span><span class="hljs-comment">//cout&lt;&lt;c[rk[l]]&lt;&lt;" ";</span>tree[o].num=<span class="hljs-number">1</span>;tree[o].lc=tree[o].val;tree[o].rc=tree[o].val;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tree[o].val=v;tree[o].num=<span class="hljs-number">1</span>;tree[o].mark=v;tree[o].lc=v;tree[o].rc=v;<span class="hljs-keyword">return</span>;&#125;pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,v,ls);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,v,rs);pushup(o);&#125;<span class="hljs-function">Tree <span class="hljs-title">merge</span><span class="hljs-params">(Tree fi,Tree se)</span></span>&#123;Tree ans;ans.num=fi.num+se.num;ans.lc=fi.lc;    <span class="hljs-comment">// bug is here</span>    <span class="hljs-comment">// se 写成了　fi</span>ans.rc=se.rc;<span class="hljs-keyword">if</span>(fi.rc==se.lc) ans.num--;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">Tree <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-comment">//cout&lt;&lt;ql&lt;&lt;" "&lt;&lt;qr&lt;&lt;endl;</span><span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> tree[o];pushdown(o);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(qr&lt;=m) <span class="hljs-keyword">return</span> query(ql,qr,ls);<span class="hljs-keyword">if</span>(ql&gt;m) <span class="hljs-keyword">return</span> query(ql,qr,rs);<span class="hljs-keyword">return</span> merge(query(ql,qr,ls),query(ql,qr,rs));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;inc(i,<span class="hljs-number">1</span>,n) &#123;Tree t=query(i,i,<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;t.val&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;Tree t=query(i,i,<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;t.lc&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;Tree t=query(i,i,<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;t.rc&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,c+i);build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-built_in">print</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-built_in">string</span> op;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">cin</span>&gt;&gt;op;<span class="hljs-keyword">if</span>(op==<span class="hljs-string">"change"</span>) &#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;update(a,b,c,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt; b;Tree o=query(a,b,<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;o.num&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-built_in">print</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="对拍程序"><a href="#对拍程序" class="headerlink" title="对拍程序"></a>对拍程序</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> c[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=ql;i&lt;=qr;i++) c[i]=v;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=ql;i&lt;qr;i++)<span class="hljs-keyword">if</span>(c[i]!=c[i+<span class="hljs-number">1</span>]) cnt++;<span class="hljs-keyword">return</span> cnt+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;inc(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,c+i);<span class="hljs-built_in">print</span>();<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-built_in">string</span> op;<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">cin</span>&gt;&gt;op;<span class="hljs-keyword">if</span>(op==<span class="hljs-string">"change"</span>) &#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;update(a,b,c);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt; b;<span class="hljs-keyword">int</span> o=query(a,b,<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span>&lt;&lt;o&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-built_in">print</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="造数据的程序"><a href="#造数据的程序" class="headerlink" title="造数据的程序"></a>造数据的程序</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;srand(time(<span class="hljs-number">0</span>));<span class="hljs-keyword">int</span> n=rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;inc(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-keyword">int</span> x=rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">int</span> m=<span class="hljs-number">100</span>;<span class="hljs-built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-keyword">int</span> o=rand()%<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(o==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"change "</span>;<span class="hljs-keyword">int</span> a=rand()%n+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=rand()%n+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> c=rand()%n+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(a&gt;b) swap(a,b);<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;c&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"que "</span>;<span class="hljs-keyword">int</span> a=rand()%n+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=rand()%n+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(a&gt;b) swap(a,b);<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_43040655/article/details/87286818" target="_blank" rel="noopener">https://blog.csdn.net/qq_43040655/article/details/87286818</a></p><p><a href="https://www.cnblogs.com/mendessy/p/11755588.html" target="_blank" rel="noopener">https://www.cnblogs.com/mendessy/p/11755588.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
      <tag>模板留存</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探树链剖分１</title>
    <link href="/2020/08/24/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%861/"/>
    <url>/2020/08/24/%E5%88%9D%E6%8E%A2%E6%A0%91%E9%93%BE%E5%89%96%E5%88%861/</url>
    
    <content type="html"><![CDATA[<p>初探树链剖分.</p><p>可能更加考察线段树:|</p><a id="more"></a><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><h3 id="资料一"><a href="#资料一" class="headerlink" title="资料一"></a>资料一</h3><p>树链剖分详解  <a href="https://www.cnblogs.com/ivanovcraft/p/9019090.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivanovcraft/p/9019090.html</a></p><p>这个资料有三个例题 :</p><p>分别是</p><p> lugou p3384  [模板]  轻重链剖分</p><p>[NOI2015]软件包管理器</p><p>[SDOI2011]染色</p><h3 id="资料二"><a href="#资料二" class="headerlink" title="资料二"></a>资料二</h3><p>树链剖分瞎入门  <a href="https://blog.csdn.net/dkacvenus/article/details/86171674" target="_blank" rel="noopener">https://blog.csdn.net/dkacvenus/article/details/86171674</a></p><p><strong> 这个资料的例题还没做:｜</strong></p><h3 id="资料三"><a href="#资料三" class="headerlink" title="资料三"></a>资料三</h3><p>树链剖分讲解及总结（重链剖分＋长链剖分）<a href="https://www.cnblogs.com/Khada-Jhin/p/9576403.html" target="_blank" rel="noopener">https://www.cnblogs.com/Khada-Jhin/p/9576403.html</a></p><p><strong> 长链剖分还未学习，好像很难的样子，重点先看重链剖分 </strong></p><h3 id="资料四"><a href="#资料四" class="headerlink" title="资料四"></a>资料四</h3><p>oi wiki   <a href="https://oi-wiki.org/graph/hld/#_8" target="_blank" rel="noopener">https://oi-wiki.org/graph/hld/#_8</a></p><h3 id="资料五"><a href="#资料五" class="headerlink" title="资料五"></a>资料五</h3><p>lca 讲的不错<br><a href="https://www.cnblogs.com/2529102757ab/p/10727254.html" target="_blank" rel="noopener">https://www.cnblogs.com/2529102757ab/p/10727254.html</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="ZJOI2008-树的统计"><a href="#ZJOI2008-树的统计" class="headerlink" title="ZJOI2008 树的统计"></a>ZJOI2008 树的统计</h3><p><a href="https://loj.ac/problem/10138" target="_blank" rel="noopener">题目链接</a></p><p>线段树类型：　单点更新，区间求最大值，区间求和</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=maxv;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-comment">// 记得初始化</span><span class="hljs-comment">// mst(head,-1)</span><span class="hljs-keyword">int</span> head[maxn];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-keyword">int</span> A[maxv];<span class="hljs-keyword">int</span> f[maxn];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxn];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>[maxn]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxn];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxn];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxn];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> id[maxn];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// get size son f d </span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;<span class="hljs-built_in">size</span>[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">size</span>[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>[v]&gt;maxson)&#123;maxson=<span class="hljs-built_in">size</span>[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>[u];&#125;<span class="hljs-comment">// get rk top id</span><span class="hljs-comment">// 记得初始化cnt=0</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;id[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>A[cnt]=val[u];rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> sum,maxn,l,r;&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].sum=tree[ls].sum+tree[rs].sum;tree[o].maxn=<span class="hljs-built_in">max</span>(tree[ls].maxn,tree[rs].maxn);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].l=l,tree[o].r=r;<span class="hljs-keyword">if</span>(tree[o].l==tree[o].r)&#123;tree[o].sum=tree[o].maxn=A[l];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o].l==tree[o].r)&#123;tree[o].sum=tree[o].maxn=v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(tree[o].l+tree[o].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(k&lt;=m) update(k,v,ls);<span class="hljs-keyword">else</span> update(k,v,rs);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=tree[o].l &amp;&amp; tree[o].r&lt;=qr)<span class="hljs-keyword">return</span> tree[o].sum;<span class="hljs-keyword">int</span> m=(tree[o].l+tree[o].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) res+=qsum(ql,qr,ls);<span class="hljs-keyword">if</span>(qr&gt;m) res+=qsum(ql,qr,rs);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=tree[o].l &amp;&amp; tree[o].r&lt;=qr) <span class="hljs-keyword">return</span> tree[o].maxn;<span class="hljs-keyword">int</span> m=(tree[o].l+tree[o].r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">if(qr&lt;=m) return qmax(ql,qr,ls);</span><span class="hljs-comment">else if(ql&gt;m)  return qmax(ql,qr,rs);</span><span class="hljs-comment">else return max(qmax(ql,m,ls),qmax(m+1,qr,rs));</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-keyword">int</span> res=INT_MIN;<span class="hljs-keyword">if</span>(ql&lt;=m) res=<span class="hljs-built_in">max</span>(res,qmax(ql,qr,ls));<span class="hljs-keyword">if</span>(qr&gt;m) res=<span class="hljs-built_in">max</span>(res,qmax(ql,qr,rs));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);ans+=qsum(id[top[x]],id[x],<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);ans+=qsum(id[x],id[y],<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> ans=INT_MIN;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,qmax(id[top[x]],id[x],<span class="hljs-number">1</span>));x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);ans=<span class="hljs-built_in">max</span>(ans,qmax(id[x],id[y],<span class="hljs-number">1</span>));<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;mst(head,<span class="hljs-number">-1</span>);tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> a,b;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);addedge(a,b);addedge(b,a);&#125;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,val+i);dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> q;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);<span class="hljs-keyword">while</span>(q--)&#123;<span class="hljs-built_in">string</span> ch;<span class="hljs-keyword">int</span> a,b;<span class="hljs-built_in">cin</span>&gt;&gt;ch&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//cout&lt;&lt;ch&lt;&lt;" "&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]==<span class="hljs-string">'M'</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,fmax(a,b));<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]==<span class="hljs-string">'S'</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,fsum(a,b));<span class="hljs-keyword">else</span> update(id[a],b,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="lougu-P2279-LCA"><a href="#lougu-P2279-LCA" class="headerlink" title="lougu P2279 LCA"></a>lougu P2279 LCA</h3><p><a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">题目链接</a></p><p><a href="https://www.cnblogs.com/zwfymqz/p/8097366.html" target="_blank" rel="noopener">自甘风月马前卒的题解</a></p><p>利用树剖解决LCA问题的需要技巧</p><h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">// 题目当中的点数为 5e5</span><span class="hljs-comment">// 个人推算 5e5就够了,但是会RE 3个点(共10个点吧)</span><span class="hljs-comment">// </span><span class="hljs-comment">// 因为之前tot和cnt混用了:| (都用的是cnt)</span><span class="hljs-comment">// 现在直接5e5就ac了</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv];<span class="hljs-keyword">int</span> tot;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> f[maxv];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxv];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>[maxv]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxv];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxv];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxv];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> id[maxv];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">// get size son f d </span><span class="hljs-comment">// cnt =0</span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;<span class="hljs-built_in">size</span>[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-built_in">size</span>[u]+=<span class="hljs-built_in">size</span>[v];<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>[v]&gt;<span class="hljs-built_in">size</span>[son[u]])son[u]=v;&#125;&#125;<span class="hljs-comment">// get rk top id</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;id[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<span class="hljs-keyword">if</span>(d[top[u]]&gt;d[top[v]])u=f[top[u]];<span class="hljs-keyword">else</span> v=f[top[v]];&#125;<span class="hljs-keyword">return</span> d[u]&gt;d[v]? v: u;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> s=<span class="hljs-built_in">read</span>();mst(head,<span class="hljs-number">-1</span>);tot=<span class="hljs-number">0</span>;<span class="hljs-comment">//cnt=1;</span>inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> b=<span class="hljs-built_in">read</span>();addedge(a,b);addedge(b,a);&#125;cnt=<span class="hljs-number">0</span>;dfs1(s,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(s,s);inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> b=<span class="hljs-built_in">read</span>();<span class="hljs-comment">//cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;</span><span class="hljs-built_in">cout</span>&lt;&lt;lca(a,b)&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="JLOI-2014-松鼠的新家"><a href="#JLOI-2014-松鼠的新家" class="headerlink" title="JLOI 2014 松鼠的新家"></a>JLOI 2014 松鼠的新家</h3><p><a href="https://loj.ac/problem/2236" target="_blank" rel="noopener">题目链接</a></p><p>利用差分，解决区间更新，最后做前缀和，得到每个点的值</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> f[maxv];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxv];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>[maxv]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxv];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxv];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxv];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> id[maxv];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-comment">// get size son f d </span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;<span class="hljs-built_in">size</span>[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">size</span>[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>[v]&gt;maxson)&#123;maxson=<span class="hljs-built_in">size</span>[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>[u];&#125;<span class="hljs-comment">// get rk top id</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;id[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<span class="hljs-keyword">if</span>(d[top[u]]&gt;d[top[v]])u=f[top[u]];<span class="hljs-keyword">else</span> v=f[top[v]];&#125;<span class="hljs-keyword">return</span> d[u]&gt;d[v]? v: u;&#125;<span class="hljs-keyword">int</span> val[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-comment">//cout&lt;&lt;"update "&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;</span>val[l]+=v;val[r+<span class="hljs-number">1</span>]-=v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;update(id[x],id[x],<span class="hljs-number">-1</span>);<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);update(id[top[x]],id[x],<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);update(id[x],id[y],<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);mst(head,<span class="hljs-number">-1</span>);tot=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> b=<span class="hljs-built_in">read</span>();addedge(a,b);addedge(b,a);val[i]=<span class="hljs-number">0</span>;&#125;val[n]=<span class="hljs-number">0</span>;<span class="hljs-comment">//---------------------------------------------------</span>cnt=<span class="hljs-number">0</span>;dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//</span>update(id[a[<span class="hljs-number">1</span>]],id[a[<span class="hljs-number">1</span>]],<span class="hljs-number">1</span>);update(id[a[n]],id[a[n]],<span class="hljs-number">-1</span>);inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> fi=a[i];<span class="hljs-keyword">int</span> se=a[i+<span class="hljs-number">1</span>];foo(fi,se);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) val[i+<span class="hljs-number">1</span>]+=val[i];<span class="hljs-keyword">int</span> o=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">int</span> p=id[i];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,val[p]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="HAOI2015-树上操作"><a href="#HAOI2015-树上操作" class="headerlink" title="HAOI2015 树上操作"></a>HAOI2015 树上操作</h3><p><a href="https://loj.ac/problem/2125" target="_blank" rel="noopener">题目链接</a></p><p>线段树的类型：　区间更新，区间求和</p><pre><code class="hljs c++"><span class="hljs-comment">// </span><span class="hljs-comment">// https://loj.ac/problem/2125 </span><span class="hljs-comment">// ac</span><span class="hljs-comment">// </span><span class="hljs-comment">// 需要注意longlong</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> f[maxv];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxv];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>[maxv]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxv];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxv];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxv];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> id[maxv];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-keyword">int</span> R[maxv];<span class="hljs-comment">// get size son f d </span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;<span class="hljs-built_in">size</span>[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">size</span>[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>[v]&gt;maxson)&#123;maxson=<span class="hljs-built_in">size</span>[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>[u];&#125;<span class="hljs-comment">// get rk top id</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;id[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) &#123;R[u]=cnt;<span class="hljs-keyword">return</span>;&#125;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;R[u]=cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<span class="hljs-keyword">if</span>(d[top[u]]&gt;d[top[v]])u=f[top[u]];<span class="hljs-keyword">else</span> v=f[top[v]];&#125;<span class="hljs-keyword">return</span> d[u]&gt;d[v]? v: u;&#125;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span>ll sum,add;<span class="hljs-keyword">int</span> l,r;&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].sum=tree[ls].sum+tree[rs].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> len)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o].add)&#123;tree[ls].add+=tree[o].add;tree[rs].add+=tree[o].add;tree[ls].sum+=tree[o].add*(len-(len&gt;&gt;<span class="hljs-number">1</span>));tree[rs].sum+=tree[o].add*(len&gt;&gt;<span class="hljs-number">1</span>);tree[o].add=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].l=l;tree[o].r=r;tree[o].add=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;tree[o].sum=<span class="hljs-number">1L</span>L*a[rk[l]];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,ll v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tree[o].add+=v;tree[o].sum+=v*(r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span>;&#125;pushdown(o,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,v,ls);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,v,rs);pushup(o);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> tree[o].sum;<span class="hljs-comment">//if(ql&lt;=tree[o].l &amp;&amp; tree[o].r&lt;=qr) return tree[o].sum;</span>pushdown(o,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) res+=query(ql,qr,ls);<span class="hljs-keyword">if</span>(m&lt;qr) res+=query(ql,qr,rs);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">CAL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>)</span></span>&#123;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y]) &#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);ans+=query(id[top[x]],id[x],<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);ans+=query(id[x],id[y],<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);mst(head,<span class="hljs-number">-1</span>);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);inc(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">int</span> fr=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> to=<span class="hljs-built_in">read</span>();addedge(fr,to);addedge(to,fr);&#125;cnt=<span class="hljs-number">0</span>;dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-keyword">int</span> type=<span class="hljs-built_in">read</span>();<span class="hljs-comment">/*</span><span class="hljs-comment">for(int i=1;i&lt;=n;i++)&#123;</span><span class="hljs-comment">cout&lt;&lt;query(i,i,1)&lt;&lt;" ";</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">cout&lt;&lt;endl;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">if</span>(type==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();ll add=<span class="hljs-built_in">read</span>();update(id[x],id[x],add,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type==<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> add=<span class="hljs-built_in">read</span>();<span class="hljs-comment">//update(id[x],id[x]+size[x]-1,add,1);</span>update(id[x],R[x],add,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type==<span class="hljs-number">3</span>)&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();ll res=CAL(x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,res);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="NOI2015-软件包管理器"><a href="#NOI2015-软件包管理器" class="headerlink" title="NOI2015 软件包管理器"></a>NOI2015 软件包管理器</h3><p><a href="https://uoj.ac/problem/128" target="_blank" rel="noopener">题目链接</a></p><p>用到的线段树的类型：　</p><p>所有的值只有01，区间赋值，区间求和　</p><p>（因为值只有０1所以处理细节区别于一般的线段树）</p><pre><code class="hljs c"><span class="hljs-comment">// https://uoj.ac/problem/128 </span><span class="hljs-comment">//ID题目提交者结果用时内存语言文件大小提交时间</span><span class="hljs-comment">// #428100#128. 【NOI2015】软件包管理器ddy1003661ms10968kbC++4.7kb2020-08-24 22:39:54 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">bool</span> show=<span class="hljs-literal">false</span>;<span class="hljs-comment">// --------------------------------------------------------</span><span class="hljs-comment">// notice : 记得更改maxv的数量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> to,nxt;&#125;edge[maxv*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> head[maxv];<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to)</span></span>&#123;edge[tot].to=to;edge[tot].nxt=head[from];head[from]=tot++;&#125;<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> f[maxv];    <span class="hljs-comment">//保存结点u的父亲结点</span><span class="hljs-keyword">int</span> d[maxv];    <span class="hljs-comment">//保存结点u的深度值</span><span class="hljs-keyword">int</span> sz[maxv]; <span class="hljs-comment">//保存以u为根的子树节点个数</span><span class="hljs-keyword">int</span> son[maxv];  <span class="hljs-comment">//保存重儿子</span><span class="hljs-keyword">int</span> rk[maxv];   <span class="hljs-comment">//保存当前dfs标号在树中所对应的节点</span><span class="hljs-keyword">int</span> top[maxv];  <span class="hljs-comment">//保存当前结点所在链的顶端节点</span><span class="hljs-keyword">int</span> pos[maxv];   <span class="hljs-comment">//保存树中每个结点剖分以后的新编号（dfs的执行顺序）</span><span class="hljs-comment">// get sz son f d </span><span class="hljs-comment">//  dfs1(root,0,1);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span> <span class="hljs-comment">// 当前节点、父亲节点、层次深度</span></span><span class="hljs-function"></span>&#123;f[u]=fa;d[u]=depth;sz[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;sz[u]+=dfs1(v,u,depth+<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(sz[v]&gt;maxson)&#123;maxson=sz[v];son[u]=v;&#125;&#125;<span class="hljs-keyword">return</span> sz[u];&#125;<span class="hljs-comment">// get rk top pos</span><span class="hljs-comment">// dfs2(root,root)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">// 当前节点，重链顶端</span></span><span class="hljs-function"></span>&#123;top[u]=t;pos[u]=++cnt; <span class="hljs-comment">//标记dfs序列</span>rk[cnt]=u;   <span class="hljs-comment">//序号cnt对应节点u</span><span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;dfs2(son[u],t);<span class="hljs-comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续， 一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];~i;i=edge[i].nxt)&#123;<span class="hljs-keyword">int</span> v=edge[i].to;<span class="hljs-keyword">if</span>(v!=son[u] &amp;&amp; v!=f[u])dfs2(v,v);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<span class="hljs-keyword">if</span>(d[top[u]]&gt;d[top[v]])u=f[top[u]];<span class="hljs-keyword">else</span> v=f[top[v]];&#125;<span class="hljs-keyword">return</span> d[u]&gt;d[v]? v: u;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><span class="hljs-keyword">int</span> sum,val;<span class="hljs-keyword">int</span> l,r;&#125;tree[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].sum=tree[ls].sum+tree[rs].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> len)</span></span>&#123;<span class="hljs-keyword">if</span>(tree[o].val==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> v=tree[o].val;tree[ls].val=v;tree[rs].val=v;tree[ls].sum=(len-(len&gt;&gt;<span class="hljs-number">1</span>))*v;tree[rs].sum=(len&gt;&gt;<span class="hljs-number">1</span>)*v;tree[o].val=<span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;tree[o].l=l;tree[o].r=r;tree[o].val=<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(l==r)&#123;tree[o].sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tree[o].val=v;tree[o].sum=v*(r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span>;&#125;pushdown(o,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,v,ls);<span class="hljs-keyword">if</span>(qr&gt;m) update(ql,qr,v,rs);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">int</span> l=tree[o].l;<span class="hljs-keyword">int</span> r=tree[o].r;<span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> tree[o].sum;pushdown(o,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) res+=query(ql,qr,ls);<span class="hljs-keyword">if</span>(m&lt;qr) res+=query(ql,qr,rs);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">install</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y=<span class="hljs-number">1</span>)</span></span>&#123;<span class="hljs-keyword">int</span> xx=x;ll ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<span class="hljs-keyword">if</span>(d[top[x]]&lt;d[top[y]]) swap(x,y);<span class="hljs-keyword">if</span>(show)<span class="hljs-built_in">cout</span>&lt;&lt;pos[top[x]]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;pos[x]&lt;&lt;<span class="hljs-built_in">endl</span>;ans+=query(pos[top[x]],pos[x],<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(show)<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;update(pos[top[x]],pos[x],<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);x=f[top[x]];&#125;<span class="hljs-keyword">if</span>(d[x]&gt;d[y]) swap(x,y);<span class="hljs-keyword">if</span>(show)<span class="hljs-built_in">cout</span>&lt;&lt;pos[x]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;pos[y]&lt;&lt;<span class="hljs-built_in">endl</span>;ans+=query(pos[x],pos[y],<span class="hljs-number">1</span>);update(pos[x],pos[y],<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(show)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"ans "</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"d[x] "</span>&lt;&lt;d[x]&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"x "</span>&lt;&lt;x&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;d[x]&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">return</span> d[xx]-ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uninstall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> o=query(pos[x],pos[x]+sz[x]<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);update(pos[x],pos[x]+sz[x]<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> o;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);inc(i,<span class="hljs-number">1</span>,n) head[i]=<span class="hljs-number">-1</span>;tot=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">2</span>,n)&#123;<span class="hljs-keyword">int</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);x++;addedge(i,x);addedge(x,i);&#125;<span class="hljs-comment">//---------------------------------------------------</span>cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;dfs1(r,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);dfs2(r,r);<span class="hljs-comment">//---------------------------------------------------</span>build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);<span class="hljs-keyword">while</span>(m--)&#123;<span class="hljs-keyword">char</span> ch[<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> x;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s %d"</span>,ch,&amp;x);x++;<span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'i'</span>) &#123;<span class="hljs-keyword">int</span> o=install(x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,o);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'u'</span>)&#123;<span class="hljs-keyword">int</span> o=uninstall(x);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,o);&#125;<span class="hljs-keyword">if</span>(show)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;query(i,i,<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
      <tag>模板留存</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础莫队</title>
    <link href="/2020/08/16/%E5%9F%BA%E7%A1%80%E8%8E%AB%E9%98%9F/"/>
    <url>/2020/08/16/%E5%9F%BA%E7%A1%80%E8%8E%AB%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<p>yesterday once more !</p><p>有空记得认真写一下啊 :)</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://keyblog.cn/article-148.html" target="_blank" rel="noopener">http://keyblog.cn/article-148.html</a></p><p><a href="https://blog.csdn.net/TDD_Master/article/details/90611940" target="_blank" rel="noopener">https://blog.csdn.net/TDD_Master/article/details/90611940</a></p><p><a href="https://www.cnblogs.com/caijiaming/p/10896352.html" target="_blank" rel="noopener">https://www.cnblogs.com/caijiaming/p/10896352.html</a></p><p><a href="https://www.cnblogs.com/WAMonster/p/10118934.html" target="_blank" rel="noopener">https://www.cnblogs.com/WAMonster/p/10118934.html</a></p><h2 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h2><p>题目地址: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6534" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6534</a></p><pre><code class="hljs c++"><span class="hljs-comment">// 337717212020-08-16 23:36:23Accepted6534483MS3132K1947 BG++mainland</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">3e5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv3=<span class="hljs-number">3</span>*maxv;<span class="hljs-keyword">int</span> c[maxv3];<span class="hljs-keyword">int</span> maxVal;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-keyword">return</span> x&amp;-x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">for</span>(;p&lt;=maxVal;p+=lowbit(p))c[p]+=v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(;p;p-=lowbit(p)) s+=c[p];<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">int</span> belong[maxv];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">query</span>&#123;</span><span class="hljs-keyword">int</span> l,r,id;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> query &amp;rhs) <span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">if</span>(belong[l]==belong[rhs.l]) <span class="hljs-keyword">return</span> belong[r]&lt;belong[rhs.r];<span class="hljs-keyword">return</span> belong[l]&lt;belong[rhs.l];&#125;&#125;q[maxv];<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-keyword">int</span> b[maxv3];<span class="hljs-keyword">int</span> l[maxv];<span class="hljs-keyword">int</span> r[maxv];<span class="hljs-keyword">int</span> w[maxv];ll ans[maxv];ll res=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-comment">//cout&lt;&lt;l[x]-1&lt;&lt;endl;</span>res+=sum(r[x])-sum(l[x]<span class="hljs-number">-1</span>);update(w[x],<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-comment">//cout&lt;&lt;l[x]-1&lt;&lt;endl;</span>update(w[x],<span class="hljs-number">-1</span>);res-=sum(r[x])-sum(l[x]<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k))&#123;<span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> block= <span class="hljs-built_in">sqrt</span>(n);inc(i,<span class="hljs-number">1</span>,n)&#123;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);b[tot++]=a[i];b[tot++]=a[i]-k;b[tot++]=a[i]+k;belong[i]=i/block;&#125;sort(b+<span class="hljs-number">1</span>,b+tot);maxVal=tot;inc(i,<span class="hljs-number">1</span>,n)&#123;l[i]=lower_bound(b+<span class="hljs-number">1</span>,b+tot,a[i]-k)-b;r[i]=lower_bound(b+<span class="hljs-number">1</span>,b+tot,a[i]+k)-b;w[i]=lower_bound(b+<span class="hljs-number">1</span>,b+tot,a[i])-b;&#125;inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r);q[i].id=i;&#125;sort(q+<span class="hljs-number">1</span>,q+m+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">0</span>;res=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">while</span>(l&lt;q[i].l) del(l++);<span class="hljs-keyword">while</span>(l&gt;q[i].l) add(--l);<span class="hljs-keyword">while</span>(r&lt;q[i].r) add(++r);<span class="hljs-keyword">while</span>(r&gt;q[i].r) del(r--);ans[q[i].id]=res;&#125;inc(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><pre><code class="hljs c++"><span class="hljs-comment">//https://blog.csdn.net/qq_34493840/article/details/94031793 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-comment">//修改了这一行就对了</span><span class="hljs-comment">//之前的数组开小了</span><span class="hljs-comment">//const int maxn = 5e4 + 100; </span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">100</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;s)</span> </span>&#123;s = <span class="hljs-number">0</span>; T w = <span class="hljs-number">1</span>, ch = getchar(); <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'-'</span>) w = <span class="hljs-number">-1</span>; ch = getchar(); &#125;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(ch)) &#123; s = (s &lt;&lt; <span class="hljs-number">1</span>) + (s &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>); ch = getchar(); &#125;s *= w; &#125;<span class="hljs-keyword">int</span> n, m, csize, qsize, ans; <span class="hljs-keyword">int</span> a[maxn], res[maxn], pos[maxn], cnt[maxm];  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">change</span> &#123;</span> <span class="hljs-keyword">int</span> p, col; &#125; c[maxn]; <span class="hljs-comment">// 记录修改的数组</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">query</span> &#123;</span> <span class="hljs-keyword">int</span> l, r, t, id; &#125; q[maxn]; <span class="hljs-comment">// 记录查询的数组</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(query aa, query bb)</span> </span>&#123; <span class="hljs-keyword">return</span> pos[aa.l] == pos[bb.l] ? (pos[aa.r] == pos[bb.r] ? aa.t &lt; bb.t : aa.r &lt; bb.r) : aa.l &lt; bb.l;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">if</span> (--cnt[x] == <span class="hljs-number">0</span>) --ans;  &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">if</span> (++cnt[x] == <span class="hljs-number">1</span>) ++ans;  &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//freopen("1.in", "r", stdin); </span><span class="hljs-comment">//freopen("1.out", "w", stdout); </span><span class="hljs-built_in">read</span>(n), <span class="hljs-built_in">read</span>(m); <span class="hljs-keyword">int</span> blo = <span class="hljs-built_in">pow</span>(n, <span class="hljs-number">0.666666</span>); <span class="hljs-comment">// n的2/3次方</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<span class="hljs-built_in">read</span>(a[i]); pos[i] = i / blo; &#125;<span class="hljs-keyword">char</span> opt[<span class="hljs-number">10</span>]; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, opt); <span class="hljs-keyword">if</span> (opt[<span class="hljs-number">0</span>] == <span class="hljs-string">'Q'</span>) &#123;++qsize; <span class="hljs-built_in">read</span>(q[qsize].l), <span class="hljs-built_in">read</span>(q[qsize].r); q[qsize].t = csize; q[qsize].id = qsize; &#125;<span class="hljs-keyword">else</span> &#123;++csize; <span class="hljs-built_in">read</span>(c[csize].p), <span class="hljs-built_in">read</span>(c[csize].col); &#125;&#125;sort(q + <span class="hljs-number">1</span>, q + qsize + <span class="hljs-number">1</span>, cmp); <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= qsize; ++i) &#123;<span class="hljs-keyword">int</span> ql = q[i].l, qr = q[i].r; <span class="hljs-keyword">while</span> (t &lt; q[i].t) &#123;++t;<span class="hljs-keyword">if</span> (l &lt;= c[t].p &amp;&amp; r &gt;= c[t].p) &#123;del(a[c[t].p]); add(c[t].col); &#125;swap(a[c[t].p], c[t].col); &#125;<span class="hljs-keyword">while</span> (t &gt; q[i].t) &#123;<span class="hljs-keyword">if</span> (l &lt;= c[t].p &amp;&amp; r &gt;= c[t].p) &#123;del(a[c[t].p]); add(c[t].col); &#125;swap(a[c[t].p], c[t].col);--t;&#125;<span class="hljs-keyword">while</span> (l &lt; ql) del(a[l++]); <span class="hljs-keyword">while</span> (l &gt; ql) add(a[--l]); <span class="hljs-keyword">while</span> (r &lt; qr) add(a[++r]); <span class="hljs-keyword">while</span> (r &gt; qr) del(a[r--]); res[q[i].id] = ans; &#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= qsize; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, res[i]); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>模板留存</tag>
      
      <tag>莫队算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020杭电多校第四场</title>
    <link href="/2020/07/31/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA/"/>
    <url>/2020/07/31/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>这是2020杭电多校的第四场。</p><p>希望可以用较为简洁的语言对于比赛进行对应的总结和回顾。</p><a id="more"></a><h2 id="可以继续看一看的题目"><a href="#可以继续看一看的题目" class="headerlink" title="可以继续看一看的题目"></a>可以继续看一看的题目</h2><p>1012   149/390  构造</p><p>1003 154/1585   随机化+dp</p><p><strong> 上述题目有时间一定记得看看 </strong></p><h2 id="warning-summary"><a href="#warning-summary" class="headerlink" title="warning summary"></a>warning summary</h2><p>每次比赛介绍后，应该更新一个warning summary表格。</p><ul><li>图论的题目，多组数据时一定要记得检查初始化搞对了没</li></ul><h2 id="1011-Kindergarten-Physics"><a href="#1011-Kindergarten-Physics" class="headerlink" title="1011 Kindergarten Physics"></a>1011 Kindergarten Physics</h2><p>这是一个非常假的题目，看到标题<code>幼儿园物理</code>可能也印证了这一点。</p><h2 id="1012-Blow-up-the-Enemy"><a href="#1012-Blow-up-the-Enemy" class="headerlink" title="1012 Blow up the Enemy"></a>1012 Blow up the Enemy</h2><p>计算出每个人需要彻底击倒一个人的时间，之后比较即可。</p><h2 id="1005-Equal-Sentences"><a href="#1005-Equal-Sentences" class="headerlink" title="1005 Equal Sentences"></a>1005 Equal Sentences</h2><p>一个比较simple的线性dp。</p><p>处理边界时Wa了几发。</p><h2 id="1004-Deliver-the-Cake"><a href="#1004-Deliver-the-Cake" class="headerlink" title="1004 Deliver the Cake"></a>1004 Deliver the Cake</h2><p>拆点最短路。</p><h2 id="1007-Go-Running"><a href="#1007-Go-Running" class="headerlink" title="1007 Go Running"></a>1007 Go Running</h2><p>模型建立之后，二分图最小点覆盖。</p><p>kuangbin的模板上有 $m\sqrt{n}$的做法。</p><p>场上没有过这个题目只是因为模板没找对，略微有些可惜。</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2020HDU多校</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>2020杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客多校第五场</title>
    <link href="/2020/07/26/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA/"/>
    <url>/2020/07/26/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>这是2020牛客多校的第五场(niukeEpsilion)。</p><p>更多地侧重于个人思考的阐释。</p><a id="more"></a><h2 id="总体回顾"><a href="#总体回顾" class="headerlink" title="总体回顾"></a>总体回顾</h2><p>这场算是比较逆风局了吧，一直卡签到题I ，不过当时决定要先别看放下题目的策略是非常正确的。</p><p>也很大程度上锻炼了比赛的心态，以及出现一些情况的应对策略。</p><p>场上还是应该加强和队友的沟通的，这样也可能激发彼此的灵感。</p><p>总之这场比赛收获还是很大的，查漏补缺，赛后积极补题和思考，这样才能更好地进步。</p><p><a href="https://ac.nowcoder.com/discuss/459448?type=101&amp;channel=1011&amp;source_id=discuss_terminal_disc" target="_blank" rel="noopener">官方简短题解的链接</a> </p><p>结合以上的题解和能查阅到的资料，进行简要的总结。</p><h2 id="F-DPS"><a href="#F-DPS" class="headerlink" title="F DPS"></a>F DPS</h2><p>按照题意模拟即可，据说会可能有爆int？。</p><p>自己手写了一下，果然wa了一发 ，修改以后才通过。</p><h3 id="可能需要提醒自己的两点内容"><a href="#可能需要提醒自己的两点内容" class="headerlink" title="可能需要提醒自己的两点内容"></a>可能需要提醒自己的两点内容</h3><ul><li>提交前看清楚<code>编译器</code>选对了没有 。</li><li>double 使用时注意不要出现比较小的数除以很大的数这种情况，这样double可能会有精度问题。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e2</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> d[maxv];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> Max)</span></span>&#123;<span class="hljs-comment">// 这种写法会wa</span><span class="hljs-comment">// 想了一下，可能是因为 Max比较大的时候，o是很小的</span><span class="hljs-comment">// 这样可能会出现double精度问题</span><span class="hljs-comment">/*</span><span class="hljs-comment">double o=d*1.0/Max;</span><span class="hljs-comment">int s=ceil(o*50.0);</span><span class="hljs-comment">*/</span><span class="hljs-keyword">int</span> s=<span class="hljs-built_in">ceil</span>(<span class="hljs-number">50.0</span>*d/Max);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'+'</span>);inc(i,<span class="hljs-number">1</span>,s) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"+\n"</span>);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'|'</span>);<span class="hljs-keyword">if</span>(d==Max) &#123;inc(i,<span class="hljs-number">1</span>,(s<span class="hljs-number">-1</span>)) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">' '</span>);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'*'</span>);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'|'</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,d);&#125;<span class="hljs-keyword">else</span> &#123;inc(i,<span class="hljs-number">1</span>,s) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">' '</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%d\n"</span>,d);&#125;<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'+'</span>);inc(i,<span class="hljs-number">1</span>,s) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"+\n"</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;<span class="hljs-keyword">int</span> Max=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,d+i);Max=<span class="hljs-built_in">max</span>(Max,d[i]);&#125;inc(i,<span class="hljs-number">1</span>,n)<span class="hljs-built_in">print</span>(d[i],Max);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="I-Hard-Math-Problem"><a href="#I-Hard-Math-Problem" class="headerlink" title="I Hard Math Problem"></a>I Hard Math Problem</h2><p>说是 困难的数学题，其实算是一个简单的数学结论？可能需要一些数学直觉。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在一个无限大的方形平面方格中，每一个格子里可以放 三种物件，标号为H、G、E，也可以什么都不放。对于物品H，周围相邻的位置必须至少放置一个G和一个E，这里相邻的定义是有一条边重合。</p><p>问：在无限大的平面中 H的个数除以平面所有方格数量的最大值是多少，保留6位小数。</p><h3 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h3><p>拿到这个题的时候就想到可能是要猜结论了。</p><p>首先发现对于2*2的方格，可以放置：</p><p>HG</p><p>EH</p><p>按照如上图形密铺的话，对应的结果是$ \frac{1}{2}$。</p><p>如果是对于3*3方格，可以放置：</p><p>HGH</p><p>EHE</p><p>HGH</p><p>将上述图形 密铺的话，对应的结果可以是$ \frac{5}{9}$。</p><p>然后就卡到了这里。。。</p><p>感觉可能还是对于数学当中<code>无限平面</code> 的理解不是很到位吧。</p><p>赛程中后段，大力猜结论， 感觉$\frac{5}{9}、\frac{4}{7}、\frac{3}{5}、\frac{2}{3}$，都是有可能的。</p><p>最后终于在提交$\frac{2}{3}=0.666667$之后通过了该题（泪目</p><p><img src="/images/CryCat.gif" srcset="/img/loading.gif"></p><p>总体上也是训练在逆风局打比赛的心态吧，对于很长时间没有想到的签到题，要有壮士断腕的勇气。</p><p>可能场上放下一段时间再看，会有新的思路和想法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依赖良好的数学直觉？（逃</p><h4 id="上图表先感受一下"><a href="#上图表先感受一下" class="headerlink" title="上图表先感受一下"></a>上图表先感受一下</h4><p>大家可以看着下方的表格感受一下，构造方案就是这么的神奇。</p><pre><code class="hljs properties"><span class="hljs-attr">H</span>  <span class="hljs-string">E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E</span><span class="hljs-attr">G</span>  <span class="hljs-string">H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G</span><span class="hljs-attr">E</span>  <span class="hljs-string">H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E</span><span class="hljs-attr">G</span>  <span class="hljs-string">H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G</span><span class="hljs-attr">E</span>  <span class="hljs-string">H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E</span><span class="hljs-attr">G</span>  <span class="hljs-string">H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G</span><span class="hljs-attr">E</span>  <span class="hljs-string">H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H</span><span class="hljs-attr">H</span>  <span class="hljs-string">E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E  H  H  E</span><span class="hljs-attr">G</span>  <span class="hljs-string">H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H  H  G  H</span></code></pre><h4 id="上述表格的构造代码"><a href="#上述表格的构造代码" class="headerlink" title="上述表格的构造代码"></a>上述表格的构造代码</h4><pre><code class="hljs c"><span class="hljs-comment">// iTable.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> n=<span class="hljs-number">20</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>) ch=<span class="hljs-string">'E'</span>;<span class="hljs-keyword">else</span> ch=<span class="hljs-string">'G'</span>;&#125;<span class="hljs-keyword">else</span> ch=<span class="hljs-string">'H'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%3c"</span>,ch);&#125;<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>真正的ICPC现场赛应该也不会出这种题目吧 ：|</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs python"><span class="hljs-comment"># python3</span>print(<span class="hljs-number">0.666667</span>)</code></pre><h2 id="E-Bogo-Sort"><a href="#E-Bogo-Sort" class="headerlink" title="E Bogo Sort"></a>E Bogo Sort</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>首先输入一个$N (1 \leq N \leq 10^5)$ ，之后输入一个长度为$n$的排列 $p_1,p_2,p_3,…,p_n$。</p><p>每一次变换时，把第$p_i$个数放到第$i$位。</p><p>问：可以给出多少个不同的长度为N的排列，在经过任意次数的变换之后，变为$1,2,3,…,n$，最后的答案可能很大，要对 $10^N$取模。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>场上比较自然的想到了这就是要计算不同置换的个数。</p><p>离散数学中当时蜻蜓点水地提到了一点点，我想我需要好好学习一下数学了。</p><p>首先可以构成环，假设一个环中数字的数量是$cnt$，这些环中的数在经过$cnt$次变换后会回到原处，可以通过写一个暴力程序非常直观的感受到这一点。</p><p>假设构成了$M$个环，环中数个数为 $cnt_1,cnt_2,cnt_3,…,cnt_m$。</p><p>那么最后的答案就是 这些数取LCM（最小公倍数）。</p><p>虽然的确猜测到了这个$10^N$可能 是虚晃一枪，但是如果给你整连续好多素数的确可能会爆long long，而且当时也不是很确定$10^N$到底是不是虚晃一枪，如果用C++ 大数模板的话，测算最大的数会出问题，所以使用<code>java</code>或<code>python</code>才是更加明智的选择，而且java和python的 IDE可以提供代码补全，所以编写时也没有想象中那么麻烦。</p><p><strong>使用不同的语言时，提交的时候一定一定要注意选好对应的编译器！</strong></p><h3 id="场上通过的java代码"><a href="#场上通过的java代码" class="headerlink" title="场上通过的java代码"></a>场上通过的java代码</h3><p>这个题用java写并不是很困难，要熟练掌握BigInteger的使用技巧啊。</p><pre><code class="hljs java"><span class="hljs-comment">//命名为Main.java程序</span><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">import</span> java.math.* ;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> p[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100010</span>];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> vis[]= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">100010</span>];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> vec[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100010</span>];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">static</span> BigInteger <span class="hljs-title">gcd</span><span class="hljs-params">(BigInteger a,BigInteger b)</span></span>&#123;        <span class="hljs-keyword">if</span>(b.equals(BigInteger.ZERO)) <span class="hljs-keyword">return</span> a;        <span class="hljs-keyword">return</span> gcd(b,a.mod(b));    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> BigInteger <span class="hljs-title">lcm</span><span class="hljs-params">(BigInteger a,BigInteger b)</span></span>&#123;        <span class="hljs-keyword">return</span> a.divide(gcd(a,b)).multiply(b);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> N=cin.nextInt();        BigInteger mod=BigInteger.TEN;        mod=mod.pow(N);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;            p[i]=cin.nextInt();        <span class="hljs-comment">//    System.out.println(p[i]);</span>        &#125;        cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++) &#123;            <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (vis[i] == <span class="hljs-keyword">false</span>) &#123;                <span class="hljs-keyword">int</span> aim = i;                <span class="hljs-keyword">int</span> iter = p[i];                t++;                <span class="hljs-keyword">while</span> (iter != aim) &#123;                    vis[iter]=<span class="hljs-keyword">true</span>;                    iter = p[iter];                    t++;                &#125;                vec[cnt++] = t;            &#125;        &#125;        BigInteger ans=BigInteger.ONE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;            BigInteger t=BigInteger.valueOf(vec[i]);            ans=lcm(ans,t);        &#125;ans=ans.mod(mod);        System.out.println(ans);        &#125;    &#125;</code></pre><h3 id="python版代码"><a href="#python版代码" class="headerlink" title="python版代码"></a>python版代码</h3><p>因为python 是动态类型语言，所以使用时要更加小心 </p><p>参考代码 </p><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=44405546" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/view-submission?submissionId=44405546</a></p><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=44405104" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/view-submission?submissionId=44405104</a></p><pre><code class="hljs python"><span class="hljs-comment"># python3</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a,b)</span>:</span>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>):        <span class="hljs-keyword">return</span> a    <span class="hljs-keyword">else</span>:         <span class="hljs-keyword">return</span> gcd(b,a%b)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lcm</span><span class="hljs-params">(a,b)</span>:</span>    <span class="hljs-comment"># 这里要使用// 这种除法</span>   <span class="hljs-comment"># 不然会WA :| </span>    <span class="hljs-keyword">return</span> a//gcd(a,b)*bn=int(input())a = [<span class="hljs-number">1</span>]temp = input().split()<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> temp:    tx = int(x)    a.append(tx)vis = [<span class="hljs-number">0</span>]* (n+<span class="hljs-number">1</span>)ans = <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):    cnt=<span class="hljs-number">0</span>    <span class="hljs-keyword">if</span>(vis[i] == <span class="hljs-number">0</span>):        aim = i         ip = a[i]        cnt+=<span class="hljs-number">1</span>        <span class="hljs-keyword">while</span>( ip!= aim):            vis[ip]=<span class="hljs-number">1</span>            ip=a[ip]            cnt+=<span class="hljs-number">1</span>        ans=lcm(ans,cnt)ans=ans%(<span class="hljs-number">10</span>**n)ans=int(ans)print(ans)</code></pre><h2 id="D-Drop-Voicing"><a href="#D-Drop-Voicing" class="headerlink" title="D Drop Voicing"></a>D Drop Voicing</h2><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>首先把这个数列放到环上去思考，这个环上有一个指针。</p><p>连续进行第二种操作的本质 是移动这个圆环上的指针，</p><p>连续进行第一种操作的本质 是把$ p_n $ 向前移动。</p><p>枚举数列起点，之后在长度为$n$的数列上寻找最长上升子序列，时间复杂度$O(n^3)$ 刚刚好。</p><h4 id="心路历程-1"><a href="#心路历程-1" class="headerlink" title="心路历程"></a>心路历程</h4><p>这个题目没搞出来略微有点可惜，场上灵光一闪在圆环上思考，以及可能要用到LIS都想到了，不过没有看透连续进行第一种操作的本质，所以场上没有通过。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> dp[maxv];<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-keyword">int</span> num[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">int</span> n=r-l+<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;num[i]=a[l+i<span class="hljs-number">-1</span>];dp[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++) <span class="hljs-keyword">if</span>(num[j]&lt;num[i]) dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> dp[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;inc(i,<span class="hljs-number">1</span>,n)&#123;a[i]=<span class="hljs-built_in">read</span>();a[i+n]=a[i];&#125;<span class="hljs-keyword">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">int</span> t=n-LIS(i,i+n<span class="hljs-number">-1</span>);ans=<span class="hljs-built_in">min</span>(ans,t);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="B-Graph"><a href="#B-Graph" class="headerlink" title="B Graph"></a>B Graph</h2><p>图论的题目，要不然就是比较简单，要不然就是要套一个比较经典的现成算法。</p><p>这道题目我个人认为属于后者。</p><p>但是这个现成的图论算法，应该<code>掌握理解</code>的啊！</p><p>目前只能当做STL，放到我的模板中了。</p><h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><blockquote><p>这里直接引用了 官方题解的表述（个人认为非常简洁和清晰</p><p>做法:可以发现任意两个点之间连边的权值都是固定的。由于图始终联通，所以两点间始终存在至少一条 路径，如果存在多条，根据环的异或和为0，两点间的路径的异或和应该相等，且始终是固定的。  </p><p>  所以可以给每个点一个权值，那么两点间的连边权值就应该是两端点权的异或。  </p><p>  接下来的问题就是异或最小生成树。</p></blockquote><h3 id="异或和最小生成树问题"><a href="#异或和最小生成树问题" class="headerlink" title="异或和最小生成树问题"></a>异或和最小生成树问题</h3><p><a href="https://www.cnblogs.com/zwfymqz/archive/2018/10/14/9786641.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/archive/2018/10/14/9786641.html</a></p><p>涉及到了01Trie，以及Boruvka算法（用于求解最小生成树的）。</p><p>具体细节看代码注释吧。</p><h3 id="这个异或最小生成树的原理一定要之后找时间认真研究！"><a href="#这个异或最小生成树的原理一定要之后找时间认真研究！" class="headerlink" title="这个异或最小生成树的原理一定要之后找时间认真研究！"></a><strong>这个<code>异或最小生成树</code>的原理一定要之后找时间认真研究</strong>！</h3><h3 id="详细注释的代码"><a href="#详细注释的代码" class="headerlink" title="详细注释的代码"></a>详细注释的代码</h3><p>模板留存 </p><pre><code class="hljs c++"><span class="hljs-comment">// </span><span class="hljs-comment">// 把很重要的应该理解的一个部分 当做了STL</span><span class="hljs-comment">// </span><span class="hljs-comment">// 确定a数组的数值的foo函数是我写的</span><span class="hljs-comment">//</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-comment">// --------------------------------------------------</span><span class="hljs-comment">//</span><span class="hljs-comment">// n 最大值是1e5</span><span class="hljs-comment">// 0&lt;= a_i &lt;=2^30</span><span class="hljs-comment">// 异或最小生成树 </span><span class="hljs-comment">// </span><span class="hljs-comment">//</span><span class="hljs-comment">// 调用前需要给定节点 int a[] 的值 下标是1-n</span><span class="hljs-comment">// 需要赋予初始值 res=0</span><span class="hljs-comment">//</span><span class="hljs-comment">// sort(a+1,a+n+1)</span><span class="hljs-comment">// dfs(1,n,29)</span><span class="hljs-comment">//</span><span class="hljs-comment">// 然后输入答案res(类型为long long)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL ll</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> tr[N * <span class="hljs-number">30</span>][<span class="hljs-number">2</span>], idx;<span class="hljs-keyword">int</span> a[N];LL res = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">29</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">int</span> x = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!tr[p][x]) tr[p][x] = ++idx;        p = tr[p][x];    &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">29</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">int</span> x = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(tr[p][x]) &#123;            p = tr[p][x];        &#125;        <span class="hljs-keyword">else</span> &#123;            p = tr[p][!x];            res += (<span class="hljs-number">1</span> &lt;&lt; i);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;    <span class="hljs-keyword">if</span>(depth == <span class="hljs-number">-1</span> || l &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = l - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(mid &lt; r &amp;&amp; ((a[mid + <span class="hljs-number">1</span>] &gt;&gt; depth) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) mid++;     dfs(l, mid, depth - <span class="hljs-number">1</span>);    dfs(mid + <span class="hljs-number">1</span>, r, depth - <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(mid == l - <span class="hljs-number">1</span> || mid == r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= mid; i++) &#123;        insert(a[i]);    &#125;    <span class="hljs-keyword">int</span> num = inf;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;        num = <span class="hljs-built_in">min</span>(num, query(a[i]));    &#125;    res += (LL)num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= idx; i++) &#123;        tr[i][<span class="hljs-number">1</span>] = tr[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    &#125;    idx = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//-------------------------------------------------------</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-keyword">int</span> to,cost;edge(<span class="hljs-keyword">int</span> to=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> cost=<span class="hljs-number">0</span>):to(to),cost(cost)&#123;&#125;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt; G[N];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;G[u].pb(edge(v,w));G[v].pb(edge(u,w));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> pre)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;edge now = G[u][i];<span class="hljs-keyword">int</span> to=now.to;<span class="hljs-keyword">int</span> w=now.cost;<span class="hljs-keyword">if</span>(to==pre) <span class="hljs-keyword">continue</span>;a[to]=a[u]^w;foo(to,u);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;inc(i,<span class="hljs-number">1</span>,n) G[i].<span class="hljs-built_in">clear</span>();inc(i,<span class="hljs-number">1</span>,(n<span class="hljs-number">-1</span>))&#123;<span class="hljs-keyword">int</span> u=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> v=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> w=<span class="hljs-built_in">read</span>();u++,v++;addedge(u,v,w);&#125;a[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;foo(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);dfs(<span class="hljs-number">1</span>,n,<span class="hljs-number">29</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,res);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>未完待续：）</p><p>要加油啊</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2020牛客多校</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>2020牛客多校</tag>
      
      <tag>模板留存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积极自由和消极自由</title>
    <link href="/2020/07/25/%E7%A7%AF%E6%9E%81%E8%87%AA%E7%94%B1%E5%92%8C%E6%B6%88%E6%9E%81%E8%87%AA%E7%94%B1/"/>
    <url>/2020/07/25/%E7%A7%AF%E6%9E%81%E8%87%AA%E7%94%B1%E5%92%8C%E6%B6%88%E6%9E%81%E8%87%AA%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>消极自由和积极自由。</p><p>这篇博文献给v8大哥，也算是借花献佛了，哈哈哈。</p><a id="more"></a><p><img src="/images/yiSaiErBoLin.jpeg" srcset="/img/loading.gif"></p><h2 id="一个有趣的探讨"><a href="#一个有趣的探讨" class="headerlink" title="一个有趣的探讨"></a>一个有趣的探讨</h2><p>我们讲突破社会范式，在讲求自由，那到底积极自由和消极自由哪个才是真自由？</p><p>积极自由讲的是自我主宰，自己治理自己，消极自由讲的是不受他人的强制干涉。在大部分情况下，二者是一体两面的，只是对自由的解读的角度不一样。但是 以赛亚·伯林 认为消极自由才是对自由更好的解读。原因在于他认为积极自由容易导向奴役之路，积极自由强调自治，自己治理自己，两个自己， 那请问前一个自己指的是什么意思呢？通常历史上支持积极自由的人会说前一个自己指的是人的理性，所以自我主宰的意思不光是不做他人的奴隶，不做社会的奴隶，还要不做自身情绪欲望的奴隶，那么这里问题就来了，什么叫做理性？谁来规定什么是理性的，什么是非理性的？我的某一个欲求到底合不合乎理性，还是说我纯粹不应该被满足的贪欲？这个定义理性的权利往往被掌握在那些最有话语权的人手里，他可能可以给你讲，你吃饱就好了，这才是理性的，你居然想吃的更好，那就是非理性的贪念，你要用你的理性克服它。这是在干什么呢？这是在把自由当做理性的工具，把自由当做终极之大用，把突破规训当做最大的规训，而这就是奴役和规训的开始。</p><h2 id="感谢赖长生的发言"><a href="#感谢赖长生的发言" class="headerlink" title="感谢赖长生的发言"></a>感谢赖长生的发言</h2><p>上述的文字其实是来自于赖长生学长在一个表演赛中延展和抒发的内容。</p><p>具体的音频链接如下：）</p><p><a href="https://www.bilibili.com/video/BV1HT4y1E72E?from=search&amp;seid=15752166315468787263" target="_blank" rel="noopener">[林圣伟大vs 赖长生] 无用之用方为大用</a></p>]]></content>
    
    
    <categories>
      
      <category>思辨-读书-看电影</category>
      
      <category>思辨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思辨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020HDU杭电多校第二场</title>
    <link href="/2020/07/24/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
    <url>/2020/07/24/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>这是2020杭电多校的第二场。<br>下面是一些题目的总结和思考。</p><a id="more"></a><h1 id="未完待续-："><a href="#未完待续-：" class="headerlink" title="未完待续 ：|"></a>未完待续 ：|</h1><h2 id="1001-Total-Eclipse"><a href="#1001-Total-Eclipse" class="headerlink" title="1001 Total Eclipse"></a>1001 Total Eclipse</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个$n$个点$m$条边的图，每个点有一个亮度值 $b_i$，最终的目标是使得所有点的亮度值都变成$0$。</p><p>每一次的操作可以选择  $k$ 个不同的点，这些点需要是联通的，对于这些点亮度值全部都减去1。</p><p>需要注意的是每一次总会选择数量最大的联通快。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>首先是数据组数   $T（1 \le T \le 10)$ ，</p><p>对于每组数据，输入 边数 $n (1 \le n \le 100000 )$ 点数 $m(1 \e m \e 200000) ， </p><p>之后输入 n个灯的亮度$b_1,b_2,…,b_n ( 1 \le b_i \le 10^9)$。</p><p>之后的  $m$ 行，输入$ u_i $和$ v_i  (1 \le u_i,v_i \le n ,u_i \ne v_i )$ ，表示双向边，注意这里在两个城市之间可能有重边。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对于每一组数据，输出最小的操作数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先在脑海里构建这样一个情景，n个点在三维空间当中代表n个柱子，高度就是给定的 b_i  ，然后水逐渐升高漫过了所有的柱子，利用<strong>逆向思维</strong>，想到所有水从最高处逐渐下降，去统计最后的答案。</p><p>最后确定的思路： 首先把所有的亮度全部加到$ans$上，之后模拟水逐渐下降的过程，具体就是把所有的边按照两个点最小的高度排序，之后倒着加边。如果这两个点不属于同一个集合，那么就将这两个点连接起来，如果这两个点属于同一个集合，那么这两个点当中比较低的高度其实是重复计算的，那么在$ans$当中减去$min(d[u_i],d[v_i]) $。</p><p>判断点属不属于同一个集合需要使用到并查集。</p><p>最后答案可能比较大，所以$ans$记得开$long long$。</p><p>小小的吐槽：</p><p>据说题目中途进行了更改，而且没有发carification，真的坑爹。</p><p>可能我读该题时运气比较好，和出题人心意相通了吧（逃</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> par[maxv];<span class="hljs-keyword">int</span> h[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;inc(i,<span class="hljs-number">0</span>,n)&#123;par[i]=i;h[i]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(x==par[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;x=<span class="hljs-built_in">find</span>(x),y=<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(h[x]&gt;h[y]) par[y]=x;<span class="hljs-keyword">else</span> &#123;par[x]=y;<span class="hljs-keyword">if</span>(h[x]==h[y]) h[y]++;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-keyword">int</span> d[maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxe=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bian</span>&#123;</span><span class="hljs-keyword">int</span> u,v;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> bian &amp; rhs) <span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">int</span> fi=<span class="hljs-built_in">min</span>(d[u],d[v]);<span class="hljs-keyword">int</span> se=<span class="hljs-built_in">min</span>(d[rhs.u],d[rhs.v]);<span class="hljs-keyword">return</span> fi&lt;se;&#125;&#125;bian[maxe];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();ll ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n)&#123;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,d+i);ans+=<span class="hljs-number">1L</span>L*d[i];par[i]=i;h[i]=<span class="hljs-number">0</span>;&#125;inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> u=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> v=<span class="hljs-built_in">read</span>();bian[i].u=u;bian[i].v=v;&#125;sort(bian+<span class="hljs-number">1</span>,bian+<span class="hljs-number">1</span>+m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<span class="hljs-keyword">int</span> u=bian[i].u;<span class="hljs-keyword">int</span> v=bian[i].v;ll temp=<span class="hljs-built_in">min</span>(d[u],d[v]);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(u)!=<span class="hljs-built_in">find</span>(v))&#123;<span class="hljs-comment">//cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;</span>   ans-=temp;unite(u,v);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="1010-Lead-of-Wisdom"><a href="#1010-Lead-of-Wisdom" class="headerlink" title="1010 Lead of Wisdom"></a>1010 Lead of Wisdom</h2><p>暴力+使用vector会被卡</p><p>待续</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2020HDU多校</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>2020杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单点更新线段树的巧妙使用[2018南京网络赛G]</title>
    <link href="/2020/07/11/%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8%5B2018%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BL%5D/"/>
    <url>/2020/07/11/%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8%5B2018%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BL%5D/</url>
    
    <content type="html"><![CDATA[<p>线段树模板留存，支持<code>单点更新</code>和<code>求最小值</code>。</p><p>巧妙地修改以后，可以支持<code>单点修改</code>和<code>查询第一个比k小的数的位置</code>。</p><a id="more"></a><h2 id="题意和思路"><a href="#题意和思路" class="headerlink" title="题意和思路"></a>题意和思路</h2><p>有缘再写：）</p><p>首先放出题目的链接  <a href="https://nanti.jisuanke.com/t/A1953" target="_blank" rel="noopener">2018南京网络赛G题  Lpl and Energy-saving Lamps</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="  2018南京网络赛G题  Lpl and Energy-saving Lamps">[1]</span></a></sup></p><p>温馨提示： 查看计蒜客的题目需要登录账号：）</p><p>题目啰啰嗦嗦说了一堆，简单来讲，是给了房间的数量$n(1\le n \le 100000 )$，</p><p>以及给了每个月Lpl每个月会买的灯泡的数量。</p><p>之后给了$n$个整数 $k_1,k_2,…k_n$，$(1 \le k_j \le 10000,j=1,2,3,…,n) $ 代表了房间当中灯泡的数量，房间的顺序就是按照Lpl刚刚给出的列表的顺序。</p><p>当Lpl拥有多余的灯泡时候，会选择优先从左向右寻找第一个小于灯泡数量的房间的位置，把该房间的灯泡全部都更换为新的灯泡，Lpl一个月只遍历一次房间，同时，若所有房间灯泡全部换完，则不再购入节能灯，停止工作。</p><p>需要注意，灯泡只需要更换一次，旧灯泡换为新灯泡之后，新灯泡不需要再次更换了。</p><p>第三行给出了一个整数 q $(1\le q \le 100000) $，q代表了查询的次数。</p><p>第四行给出了q个数$d_1,d_2,…,d_q(1 \le d_p \le 100000,p=1,2,3,…,q)$ 代表要查询$d_p$月的情况。</p><p>这里需要强调的是月份是从1月开始的，在第一个月，Lpl会购买m个灯泡。</p><p>对于每一组查询，要输出 两个数，一个是所有的旧的灯泡以及全部被替换掉的房间的数量，另一个是在$d_p$月结束时还剩下了多少个灯泡。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>就是比较朴素的模拟，需要利用一个支持<code>单点修改</code>和<code>查询第一个比k小的数的位置</code>的线段树。</p><h2 id="代码留存"><a href="#代码留存" class="headerlink" title="代码留存"></a>代码留存</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-keyword">int</span> b[maxv];<span class="hljs-keyword">int</span> sum[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> x,y;&#125;lamp[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;sum[o]=<span class="hljs-built_in">min</span>(sum[ls],sum[rs]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(l==r)&#123;sum[o]=a[l];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(l==r)&#123;sum[o]=v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=m) update(p,v,lson);<span class="hljs-keyword">else</span> update(p,v,rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(sum[o]&gt;k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(sum[ls]&lt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(k,lson);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum[rs]&lt;=k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(k,rson);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);<span class="hljs-keyword">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> maxnum=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,q)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,b+i);maxnum=<span class="hljs-built_in">max</span>(maxnum,b[i]);&#125;build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> num1=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> num2=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt;inc(i,<span class="hljs-number">1</span>,maxnum)&#123;<span class="hljs-keyword">if</span>(num1&lt;n) num2+=m;<span class="hljs-keyword">while</span>(cnt=<span class="hljs-built_in">find</span>(num2,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>))&#123;num2-=a[cnt];update(cnt,inf,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);num1++;&#125;lamp[i].x=num1;lamp[i].y=num2;&#125;inc(i,<span class="hljs-number">1</span>,q)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;lamp[b[i]].x&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;lamp[b[i]].y&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://nanti.jisuanke.com/t/A1953" target="_blank" rel="noopener">2018南京网络赛G题  Lpl and Energy-saving Lamps</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/dilthey/p/9571698.html" target="_blank" rel="noopener">https://www.cnblogs.com/dilthey/p/9571698.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/wjc2021/p/11241313.html" target="_blank" rel="noopener">https://www.cnblogs.com/wjc2021/p/11241313.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>备用模板</category>
      
      <category>2018年网络赛补题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cfEdu89的A题-E题</title>
    <link href="/2020/06/13/cfEdu89-a-e/"/>
    <url>/2020/06/13/cfEdu89-a-e/</url>
    
    <content type="html"><![CDATA[<p>首先放题目链接  <a href="https://codeforces.com/contest/1366" target="_blank" rel="noopener">Educational Codeforces Round 89</a></p><p>下面是A-E题目我的思路总结。</p><a id="more"></a><h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><h3 id="题意归纳"><a href="#题意归纳" class="headerlink" title="题意归纳"></a>题意归纳</h3><p> 制作某种工具有两个方式，第一种是1个材料A+2个材料B，第二种是2个材料A+1个材料B，现在有A材料$\ a\ $个，B材料$\ b\ $个，问最多能制作几个想要的工具。</p><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>第一行输入数据组数 $t$, 数据范围$1\leq t \leq 1000$。</p><p>之后$t$行，每行有两个整数 $a$ 和 $b$ ，$(0\leq a,b\leq 10^9)$。</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>思维题。</p><p>如果$a&gt;b$的话就先调换顺序,保证$a&lt;b$。</p><p>得到一个差值$cnt=b-a$，如果这个差值刚好大于等于$a$，那么最后的答案等于$a$；</p><p>如果$cnt&lt;a$，那么我们需要处理的子问题就变成了材料A和材料B的数量均为$a-cnt$时能造多少工具，这里具体细节见代码吧。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-keyword">int</span> t;ll a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">cin</span>&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)&#123;<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="hljs-keyword">if</span>(a&gt;b) swap(a,b);ll cha=b-a;<span class="hljs-keyword">if</span>(cha&gt;=a)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cha&lt;a)&#123;ll ans=cha;a-=cha;b-=<span class="hljs-number">2</span>*cha;ans+=a/<span class="hljs-number">3</span>*<span class="hljs-number">2</span>;a-=a/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>;b-=b/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>;<span class="hljs-comment">//cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>&amp;&amp;b&gt;=<span class="hljs-number">1</span>) ans++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">2</span>&amp;&amp;a&gt;=<span class="hljs-number">1</span>) ans++;<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><h3 id="一句话题解"><a href="#一句话题解" class="headerlink" title="一句话题解"></a>一句话题解</h3><p>不停地增加含有x的区间的交集。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-comment">//省略了代码头部，可以参考A题目的代码头部</span><span class="hljs-keyword">int</span> t;<span class="hljs-keyword">int</span> n,x,m;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e2</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> l[maxv],r[maxv];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)&#123;n=<span class="hljs-built_in">read</span>();x=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> tl=x,tr=x;inc(i,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> l=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> r=<span class="hljs-built_in">read</span>();<span class="hljs-comment">//两个区间有交集，就可以选择扩大当前选择的区间了</span><span class="hljs-keyword">if</span>(tl&gt;=l&amp;&amp;tl&lt;=r) tl=<span class="hljs-built_in">min</span>(tl,l),tr=<span class="hljs-built_in">max</span>(tr,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr&gt;=l&amp;&amp;tr&lt;=r) tl=<span class="hljs-built_in">min</span>(tl,l),tr=<span class="hljs-built_in">max</span>(tr,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;=tl&amp;&amp;l&lt;=tr) tl=<span class="hljs-built_in">min</span>(tl,l),tr=<span class="hljs-built_in">max</span>(tr,r);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r&gt;=tl&amp;&amp;r&lt;=tr) tl=<span class="hljs-built_in">min</span>(tl,l),tr=<span class="hljs-built_in">max</span>(tr,r);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,tr-tl+<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><h3 id="一句话题解-1"><a href="#一句话题解-1" class="headerlink" title="一句话题解"></a>一句话题解</h3><p>要求一个矩形矩阵从$(1,1)$到$(n,m)$的路径上的0或1是对称的，</p><p>那么对于每一个坐标我们可以求解一个值，</p><p>$dis=min(该点到(1,1)的距离，该点到(n,m)的距离)$</p><p>这个值相同的点上的数必须是相同的。</p><p>特别注意的是 到$(1,1)$和$(n,m)$的距离相同的点不需要纳入计算考虑范围。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c"><span class="hljs-comment">//省略了头文件</span><span class="hljs-keyword">int</span> t;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">30</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> a[maxv][maxv];<span class="hljs-keyword">int</span> n,m;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; zero;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; one;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)&#123;n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);zero.<span class="hljs-built_in">clear</span>();one.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">int</span> sum=n+m<span class="hljs-number">-2</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,n) inc(j,<span class="hljs-number">1</span>,m)&#123;<span class="hljs-keyword">int</span> now=<span class="hljs-built_in">min</span>(i<span class="hljs-number">-1</span>+j<span class="hljs-number">-1</span>,sum-(i<span class="hljs-number">-1</span>+j<span class="hljs-number">-1</span>));<span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>+j<span class="hljs-number">-1</span>==sum-(i<span class="hljs-number">-1</span>+j<span class="hljs-number">-1</span>)) <span class="hljs-keyword">continue</span>;cnt=<span class="hljs-built_in">max</span>(cnt,now);<span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>) zero[now]++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">1</span>) one[now]++;&#125;<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">0</span>,cnt)&#123;ans+=<span class="hljs-built_in">min</span>(zero[i],one[i]);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="D题目"><a href="#D题目" class="headerlink" title="D题目"></a>D题目</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你$n$个数$a_1,a_2,a_3,…,a_n$。</p><p>对于每一个$a_i$ 需要找到它的两个因子$d_1&gt;1$和$d_2&gt;1$满足$gcd(d_1+d_2,a_i)=1$，如果满足的话那么就输出 $d_1\ d_2$  ，如果 找不到就输出$-1 \ -1$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种题当然要往分解质因数的角度去考虑啦，我们知道任何的一个数，都可以表示成质因子乘积的形式，如下所示：</p><script type="math/tex; mode=display">a = p_1^{n_1}*p_2^{n_2}*p_3^{n3}*...*p_k^{n_k}</script><p>我们令$d_1=p_1^{n_1}$，$d_2=a/d_1$，我们可以惊喜地发现是满足条件的。</p><p>其实我也想了很久的啊=_=，但是结论的确非常简单。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c++"><span class="hljs-comment">//省略了头文件</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> prime[maxv];<span class="hljs-keyword">int</span> xiao[maxv];<span class="hljs-keyword">int</span> tot;<span class="hljs-keyword">bool</span> np[maxv];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> Max=<span class="hljs-number">1e7</span>;inc(i,<span class="hljs-number">0</span>,Max) np[i]=<span class="hljs-literal">false</span>;tot=<span class="hljs-number">0</span>; np[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=Max;i++)&#123;<span class="hljs-keyword">if</span>(np[i]==<span class="hljs-literal">false</span>)&#123;prime[++tot]=i;xiao[i]=i;    <span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;xiao[i]&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot;j++)&#123;<span class="hljs-keyword">if</span>(i*prime[j]&gt;Max) <span class="hljs-keyword">break</span>;np[i*prime[j]]=<span class="hljs-literal">true</span>;<span class="hljs-comment">///cout&lt;&lt;i*prime[j]&lt;&lt;" "&lt;&lt;prime[j]&lt;&lt;endl;</span>xiao[i*prime[j]]=prime[j];<span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> l[maxn],r[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;sieve();n=<span class="hljs-built_in">read</span>();inc(i,<span class="hljs-number">1</span>,n)&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> abak=a;<span class="hljs-keyword">int</span> s=xiao[a];<span class="hljs-comment">//cout&lt;&lt;a&lt;&lt;" "&lt;&lt;s&lt;&lt;endl;</span><span class="hljs-keyword">if</span>(s==a) l[i]=r[i]=<span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> fi=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(a%s==<span class="hljs-number">0</span>)&#123;a/=s;fi*=s;&#125;<span class="hljs-keyword">if</span>(a!=<span class="hljs-number">1</span>)&#123;l[i]=fi;r[i]=a;&#125;<span class="hljs-keyword">else</span> l[i]=r[i]=<span class="hljs-number">-1</span>;&#125;&#125;inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,l[i]);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);inc(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,r[i]);<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h2><h3 id="一句话题解-2"><a href="#一句话题解-2" class="headerlink" title="一句话题解"></a>一句话题解</h3><p>枚举？！</p><p>… 大家直接看代码吧</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rt o</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[maxv];<span class="hljs-keyword">int</span> b[maxv];<span class="hljs-keyword">int</span> Min[maxv&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> cur;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span></span>&#123;Min[rt]=<span class="hljs-built_in">min</span>(Min[ls],Min[rs]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> rt)</span></span>&#123;<span class="hljs-keyword">if</span>(l==r)&#123;Min[rt]=a[++cur];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(rt);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> rt)</span></span>&#123;<span class="hljs-keyword">if</span>(l==r)&#123;Min[rt]=num;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(pos&lt;=m) update(pos,num,lson);<span class="hljs-keyword">else</span> update(pos,num,rson);pushup(rt);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> rt)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) <span class="hljs-keyword">return</span> Min[rt];<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> _=INT_MAX;<span class="hljs-keyword">if</span>(ql&lt;=m) _=<span class="hljs-built_in">min</span>(_,query(ql,qr,lson));<span class="hljs-keyword">if</span>(qr&gt;m) _=<span class="hljs-built_in">min</span>(_,query(ql,qr,rson));<span class="hljs-keyword">return</span> _;&#125;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;ll mod=<span class="hljs-number">998244353</span>; <span class="hljs-keyword">bool</span> show=<span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;show=<span class="hljs-literal">false</span>;<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;mp.<span class="hljs-built_in">clear</span>();inc(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);mp[a[i]]=i;&#125;inc(i,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,b+i);cur=<span class="hljs-number">0</span>;build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>;ll ans=<span class="hljs-number">0</span>;inc(i,<span class="hljs-number">1</span>,m) <span class="hljs-keyword">if</span>(mp[b[i]]==<span class="hljs-number">0</span>) flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span>(flag)&#123;ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(query(<span class="hljs-number">1</span>,mp[b[<span class="hljs-number">1</span>]],<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>)!=b[<span class="hljs-number">1</span>]) flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span>(query(mp[b[m]],n,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>)!=b[m]) flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-keyword">int</span> l=mp[b[i]];<span class="hljs-keyword">int</span> r=mp[b[i+<span class="hljs-number">1</span>]];<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=r;j&gt;l;j--)&#123;<span class="hljs-keyword">int</span> fi=query(l,j<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> se=query(j,r,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(fi==b[i]&amp;&amp;se==b[i+<span class="hljs-number">1</span>]) cnt++;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125;ans=(ans*cnt)%mod;&#125;&#125;<span class="hljs-keyword">if</span>(flag==<span class="hljs-literal">false</span>) ans=<span class="hljs-number">0</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这算是鸽了一次实时打cf之后补题的。</p><p>做的时候其实一卡一卡的，思维不是很到位，编码速度也不是很够。</p><p>总是想清楚以后再开始写吧，不要着急，磨刀不误砍柴工，要不然就会越写越乱，还要不停调试，更加耗费时间了。</p><p>要有信心和毅力啊，我们一起在这个夏天上分吧 ：）</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>codeforces</tag>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018沈阳网络赛c题（莫比乌斯函数+容斥）</title>
    <link href="/2020/06/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0+%E5%AE%B9%E6%96%A5%5B2018%E6%B2%88%E9%98%B3%E7%BD%91%E7%BB%9C%E8%B5%9Bc%5D/"/>
    <url>/2020/06/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0+%E5%AE%B9%E6%96%A5%5B2018%E6%B2%88%E9%98%B3%E7%BD%91%E7%BB%9C%E8%B5%9Bc%5D/</url>
    
    <content type="html"><![CDATA[<p>2018年沈阳网络赛c Convex Hull。<br>虽然顶了一个计算几何的名字，实际上是一个数学题。<br>涉及到了莫比乌斯函数和容斥的知识，以及一些<del>奇技淫巧</del>调试技巧。<br><a id="more"></a> </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>这里大家可以直接查看计蒜客上的题目 <del>放链接！</del> <a href="https://nanti.jisuanke.com/t/A1991" target="_blank" rel="noopener">2018沈阳网络赛c题 Convex Hull</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="2018沈阳网络赛c题 Convex Hull ">[1]</span></a></sup></p><p>温馨提示：查看计蒜客的题目需要登录账号哦 ：）</p><p>我们首先定义函数 $gay(i)$: </p><script type="math/tex; mode=display">gay(i) =\begin{cases}0,  & \text{ if $i=k*x*x,x\gt1,k\ge1$}     \\i*i, & \text{else }          \\\end{cases}</script><p>然后我们的任务是计算：</p><script type="math/tex; mode=display">\begin{equation}\begin{split}\sum_{num=1} ^{n}(\sum _{i=1} ^{num} gay(i)) \mod\ p \end{split}\end{equation}</script><p>多组输入，数据组数不超过100组。</p><p>每组输入有两个整数 $n$ 和 $p$  , 数据范围 为 $1\le n \le 10^{10}，1\le p\le 10^{11}$。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-number">10</span><span class="hljs-number">8</span> <span class="hljs-number">19230817</span></code></pre><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><pre><code class="hljs c++"><span class="hljs-number">1</span><span class="hljs-number">396</span></code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先分析$gay(i)$函数，可以发现当i中含有平方因子时 ,$gay(i)=0$ ,我们这时就应该想到<code>莫比乌斯函数</code>了，可以利用莫比乌斯函数对$gay(i)$ 函数进行一个等价表示：</p><script type="math/tex; mode=display">gay(i)=\mu^{2}(i)*i^{2}</script><p>作为一个不是 特别懂莫比乌斯函数的人，当然要多查阅一些相关资料啦。</p><p>这里提供一些我参考的莫比乌斯函数的基础资料和扩展资料。</p><p><a href="https://wenku.baidu.com/view/542961fdba0d4a7302763ad5.html" target="_blank" rel="noopener">贾志鹏 线性筛法与积性函数</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="贾志鹏 线性筛法与积性函数">[2]</span></a></sup></p><p><a href="https://blog.csdn.net/skywalkert/article/details/50500009" target="_blank" rel="noopener">浅谈一类积性函数的前缀和</a> <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="浅谈一类积性函数的前缀和 ">[3]</span></a></sup></p><p><del>事实上我也只是看了皮毛，数学功底要加强啊 !</del></p><p>对于题目的思路主要参考了qkoqhh的博客<a href="https://blog.csdn.net/qkoqhh/article/details/82532516" target="_blank" rel="noopener">2018沈阳网络赛C(莫比乌斯函数+容斥)</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="2018沈阳网络赛C(莫比乌斯函数+容斥)">[4]</span></a></sup>，我的这篇博文进行了更加详细的分析。</p><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>回到我们需要求的公式，现在我们要开始<strong>推公式</strong>啦！</p><p><strong>提前注明：之后的公式为了方便，统一省略了<script type="math/tex">\mod p</script> 。</strong></p><script type="math/tex; mode=display">\begin{align}&\sum_{num=1} ^{n}\sum _{i=1} ^{num} gay(i) \\=& \sum _{num=1} ^{n} {\sum _{i=1} ^{num}}\mu^{2}(i)*i^{2}  \\=& \sum _{i=1} ^{n} {\mu^2(i)*(n-i+1)}  \\=& (n+1)\sum_{i=1}^{n}{\mu^2(i)*i^2}-\sum_{i=1}^{n}{\mu^2(i)*i^3}  \\\tag1\end{align}</script><p>第二行到第三行的转化可以有两种方法理解，第一种就是非常直观的<strong>列举前几项</strong>感受一下具体$ \mu^2(i)$ 会被计算几次。第二种是利用<strong>二重积分交换积分限</strong>的思路来理解，事实上，第一种方法更加的直观。<br>之后我们要集中处理 $ \sum_{i=1}^{n} \mu^2(i)*i^2 $，这里使用到了容斥的思想，我会对这一部分进详细的分析。</p><p>首先我们来思考一道更加简单的题目bzoj2440，这个题目需要解决的一个子问题是，给定区间$[1,n]$求出这个区间中不含有平方因子的数的个数。本质上是要求解$\sum_{i=1}^{n}\mu^2(i)$。</p><p>事实上这个公式可以利用容斥原来的思想 推导出更加方便运算的形式：</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^{n}\mu^2(i)=\sum_{i=1}^{\sqrt{n}}\mu(i) \lfloor \frac{n}{i^2} \rfloor \tag2\end{align}</script><p>大家可以跟着我一起来思考，对于公式左边的$i$，只有当$i$不含有平方因子时，$\mu(i)$不等于$0$，对于最后的结果才有贡献。</p><p>第二步就是要利用容斥来计算出答案，对于一个平方因子$i^2$，$[1,n]$中含有该平方因子的数的个数是$\lfloor\frac{n}{i^2}\rfloor $，</p><p>设最后的答案为$ans$，$ans=n-含有2^2因子的个数-含有3^2因子的个数+含有2^2*3^2因子的个数…$，容斥的系数刚好就是$\mu(i)$。</p><p>我们可以通过分析前几项的方式来感受一下：</p><p>当$i=1$时，$\lfloor\frac{n}{1^2}\rfloor $代表这个区间所有数的数量，这一项的系数为1；</p><p>当$i=2$时，含有平方因子$2^2$的数的数量是$\lfloor\frac{n}{2^2}\rfloor$，我们需要减去这个数，这一项的系数为-1；</p><p>当$i=3$时，含有平方因子$3^2$的数的数量是$\lfloor\frac{n}{3^2}\rfloor$，我们需要减去这个数，这一项的系数为-1；</p><p>当$i=4$时，含有平方因子$4^2$的数的数量是$\lfloor\frac{n}{4^2}\rfloor$，因为在$i=2$时我们已经处理了含有平方因子$4^2$的数，所以这一项的系数是0。</p><p>当$i=5$时，含有平方因子$5^2$的数的数量是$\lfloor\frac{n}{5^2}\rfloor$，我们需要加上这个数，这一项的系数为1；</p><p>当$i=6$时，含有平方因子$6^2$的数的数量是$\lfloor\frac{n}{6^2}\rfloor$，在$i=2$和$i=3$时，含有平方因子$6^2$的数被减了两次，所以我们需要加上这个数，这一项的系数为1；</p><p>当$i=7$时，含有平方因子$7^2$的数的数量是$\lfloor\frac{n}{7^2}\rfloor$，我们需要加上这个数，这一项的系数为1；</p><p>当$i=8$时，含有平方因子$8^2$的数的数量是$\lfloor\frac{n}{7^2}\rfloor$，在$i=2$时，含有平方因子$8^2$的数已经被处理过了，所以这一项的系数为0；</p><p>……</p><p>通过前几项的分析，相信大家对于容斥以及枚举平方因子时系数的选择的过程一定有了一个直观的理解。</p><p>我们可以利用同样的思路去求解<script type="math/tex">\sum_{i=1}^{n}\mu^2(i)*i^2\</script>和<script type="math/tex">\ \sum_{i=1}^{n}\mu^2(i)*i^3\</script>:</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^{n}\mu^2(i)*i^2=\sum_{i=1}^{\sqrt{n}}\mu(i) \sum_{k=1}^{\lfloor \frac{n}{i^2}  \rfloor}(ki^2)^2\tag3\\\sum_{i=1}^{n}\mu^2(i)*i^3=\sum_{i=1}^{\sqrt{n}}\mu(i) \sum_{k=1}^{\lfloor \frac{n}{i^2} \rfloor}(ki^2)^3 \tag4\\\end{align}</script><p>将上述公式带入 公式$(1)$：</p><script type="math/tex; mode=display">\begin{align}&(n+1)\sum_{i=1}^{n}{\mu^2(i)*i^2}-\sum_{i=1}^{n}{\mu^2(i)*i^3}\\=&(n+1)\sum_{i=1}^{\sqrt{n}}\mu^2(i)*\sum_{k=1}^{\lfloor \frac{n}{i^2}\rfloor}(ki)^2-\sum_{i=1}^{\sqrt{n}}\mu^2(i)*\sum_{k=1}^{\lfloor \frac{n}{i^2}\rfloor}(ki)^3\\=&(n+1)\sum_{i=1}^{\sqrt{n}}\mu(i)i^4*\sum_{k=1}^{\lfloor \frac{n}{i^2}\rfloor}k^2-\sum_{i=1}^{\sqrt{n}}\mu(i)i^6*\sum_{k=1}^{\lfloor \frac{n}{i^2}\rfloor}k^3\\\tag5 \end{align}</script><p>然后我们可以在$O(\sqrt{n})$的时间复杂度内，求解出最后的答案。</p><p>这里利用了两个公式，分别是平方根求和公式和立方根求和公式。</p><p>平方根求和公式：</p><script type="math/tex; mode=display">1^2+2^2+3^3+...+n^2=\frac{n*(n+1)*(2*n+1)}{6} \tag6</script><p>立方根求和公式：</p><script type="math/tex; mode=display">1^3+2^3+3^3+...+n^3=(\frac{n*(n+1)}{2})^2\tag7</script><p>**求解时记得对$p$取模：）</p><h3 id="int128的使用"><a href="#int128的使用" class="headerlink" title="int128的使用"></a>int128的使用</h3><p>运算过程种会爆long long，所以要使用int128，<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9198885.html" target="_blank" rel="noopener">int218的参考资料</a> <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="int218的参考资料">[5]</span></a></sup></p><p>下面是使用int128的模板，实际上这个题目当中int128是作为一个中间变量来使用的。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> __int128 <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    __int128 x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;    <span class="hljs-keyword">char</span> ch=getchar();    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">'0'</span>||ch&gt;<span class="hljs-string">'9'</span>)    &#123;        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>)            f=<span class="hljs-number">-1</span>;        ch=getchar();    &#125;    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">'0'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'9'</span>)    &#123;        x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;        ch=getchar();    &#125;    <span class="hljs-keyword">return</span> x*f;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(__int128 x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);        x=-x;    &#125;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)        <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    __int128 a = <span class="hljs-built_in">read</span>();    __int128 b = <span class="hljs-built_in">read</span>();    <span class="hljs-built_in">write</span>(a + b);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><h3 id="c-版本代码"><a href="#c-版本代码" class="headerlink" title="c++版本代码"></a>c++版本代码</h3><p>c++版本，这里的莫比乌斯函数的求解可以作为模板。</p><p>下面是ac的代码。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sqr(x) ((x)*(x))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxv=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">bool</span> np[maxv];<span class="hljs-keyword">int</span> mu[maxv],prime[maxv],tot;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;tot=<span class="hljs-number">0</span>;mst(mu,<span class="hljs-number">0</span>);mst(np,<span class="hljs-number">0</span>);mu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;np[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;inc(i,<span class="hljs-number">2</span>,n)&#123;<span class="hljs-keyword">if</span>(!np[i]) prime[++tot]=i,mu[i]=<span class="hljs-number">-1</span>;inc(j,<span class="hljs-number">1</span>,tot)&#123;<span class="hljs-keyword">if</span>(i*prime[j]&gt;n) <span class="hljs-keyword">break</span>;np[i*prime[j]]=<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;   mu[i*prime[j]]=<span class="hljs-number">0</span>;   <span class="hljs-keyword">break</span>;&#125;mu[i*prime[j]]=mu[i]*mu[prime[j]];&#125;&#125;&#125;__int128 ans,p,inf;ll n; <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll n)</span></span>&#123;__int128 x=n,y=n+<span class="hljs-number">1</span>,z=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) x/=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) y/=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> z/=<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) x/=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) y/=<span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> z/=<span class="hljs-number">3</span>;<span class="hljs-keyword">return</span> (ll)(x*y%p*z%p);&#125;<span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(ll n)</span></span>&#123;__int128 x=n,y=n+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) x/=<span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> y/=<span class="hljs-number">2</span>;x=x*y%p;x=x*x%p;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ll o;sieve(<span class="hljs-number">100000</span>);<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;o))&#123;p=o;ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123;__int128 ff=<span class="hljs-number">1L</span>L*mu[i]*i*i*i%p*i%p*i%p*i%p;__int128 gg=<span class="hljs-number">1L</span>L*mu[i]*i*i%p*i%p*i%p;ans+=p+gg*sum(n/sqr(i))%p*(n+<span class="hljs-number">1</span>)%p-ff*pre(n/sqr(i))%p;ans%=p;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(ll)ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="java版本代码"><a href="#java版本代码" class="headerlink" title="java版本代码"></a>java版本代码</h3><p>写完之后我还写了一个java版本的代码，因为题目没有提示java的时间限制是多少，估计出题方开的时间限制和c++版本的是一样的，写完之后提交果然T飞了（时间超限），所以写了一个生成随机数的程序，简单对拍了一下。下面的java 代码应该是没有问题的。</p><p>使用java编写代码，其实就是为了使用BigInteger类（大整数类），这样可以使用无限范围大的整数。</p><p>BigInteger大整数类的参考资料 <a href="https://blog.csdn.net/u010304217/article/details/37728493" target="_blank" rel="noopener">Java中的BigInteger在ACM中的应用</a><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Java中的BigInteger在ACM中的应用">[6]</span></a></sup>。</p><p>java编写程序时必须是要使用Main作为类名。</p><pre><code class="hljs java"><span class="hljs-comment">// 1500ms 的限制下tle了</span><span class="hljs-comment">// 对java这么不友好吗</span><span class="hljs-comment">// 对拍了应该是对的</span><span class="hljs-comment">//</span><span class="hljs-keyword">import</span> java.math.BigInteger;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxv=(<span class="hljs-keyword">int</span>)(<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] mu=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxv];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] prime=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxv];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span>[] np=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[maxv];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> tot;    <span class="hljs-keyword">static</span> BigInteger ans= <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"0"</span>);    <span class="hljs-keyword">static</span> BigInteger p = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"0"</span>);    <span class="hljs-keyword">static</span> BigInteger n = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"0"</span>);    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;        tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxv;i++) &#123;            mu[i] = <span class="hljs-number">0</span>;            np[i] = <span class="hljs-keyword">false</span>;        &#125;        mu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        np[<span class="hljs-number">1</span>]=<span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            <span class="hljs-keyword">if</span>(!np[i])&#123;                prime[++tot]=i;                mu[i]=-<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot;j++)&#123;                <span class="hljs-keyword">if</span>(i*prime[j]&gt;n) <span class="hljs-keyword">break</span>;                np[i*prime[j]]=<span class="hljs-keyword">true</span>;                <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;                    mu[i*prime[j]]=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;                mu[i*prime[j]]=mu[i]*mu[prime[j]];            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> BigInteger <span class="hljs-title">sum</span><span class="hljs-params">(BigInteger n)</span></span>&#123;        BigInteger x=n;        BigInteger y=n.add(BigInteger.ONE);        BigInteger z=n.multiply(BigInteger.valueOf(<span class="hljs-number">2</span>)).add(BigInteger.valueOf(<span class="hljs-number">1</span>));        <span class="hljs-keyword">if</span>(x.mod(BigInteger.valueOf(<span class="hljs-number">2</span>)).equals(BigInteger.ZERO)) x=x.divide(BigInteger.valueOf(<span class="hljs-number">2</span>));        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y.mod(BigInteger.valueOf(<span class="hljs-number">2</span>)).equals(BigInteger.ZERO)) y=y.divide(BigInteger.valueOf(<span class="hljs-number">2</span>));        <span class="hljs-keyword">else</span> z=z.divide(BigInteger.valueOf(<span class="hljs-number">2</span>));        <span class="hljs-keyword">if</span>(x.mod(BigInteger.valueOf(<span class="hljs-number">3</span>)).equals(BigInteger.ZERO)) x=x.divide(BigInteger.valueOf(<span class="hljs-number">3</span>));        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y.mod(BigInteger.valueOf(<span class="hljs-number">3</span>)).equals(BigInteger.ZERO)) y=y.divide(BigInteger.valueOf(<span class="hljs-number">3</span>));        <span class="hljs-keyword">else</span> z=z.divide(BigInteger.valueOf(<span class="hljs-number">3</span>));        <span class="hljs-keyword">return</span> x.multiply(y).mod(p).multiply(z).mod(p);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> BigInteger <span class="hljs-title">pre</span><span class="hljs-params">(BigInteger n)</span></span>&#123;        BigInteger x=n;        BigInteger y=n.add(BigInteger.ONE);        <span class="hljs-keyword">if</span>(x.mod(BigInteger.valueOf(<span class="hljs-number">2</span>)).equals(BigInteger.ZERO)) x=x.divide(BigInteger.valueOf(<span class="hljs-number">2</span>));        <span class="hljs-keyword">else</span> y=y.divide(BigInteger.valueOf(<span class="hljs-number">2</span>));        x=x.multiply(y).mod(p);        x=x.multiply(x).mod(p);        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        sieve(<span class="hljs-number">100000</span>);        Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span>(in.hasNext())&#123;            n=in.nextBigInteger();            p=in.nextBigInteger();            ans=BigInteger.ZERO;            BigInteger i=BigInteger.valueOf(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(;i.multiply(i).compareTo(n)&lt;=<span class="hljs-number">0</span>;i=i.add(BigInteger.ONE))&#123;                <span class="hljs-keyword">int</span> ip=i.intValue();                BigInteger ff=BigInteger.valueOf(mu[ip]);                ff=ff.multiply(i).multiply(i).multiply(i).mod(p).multiply(i).mod(p).multiply(i).mod(p).multiply(i).mod(p);                BigInteger gg=BigInteger.valueOf(mu[ip]);                gg=gg.multiply(i).multiply(i).mod(p).multiply(i).mod(p).multiply(i).mod(p);                ans=ans.add(p);                BigInteger fi=sum(n.divide(i.multiply(i)));                fi=fi.multiply(gg).mod(p).multiply(n.add(BigInteger.ONE)).mod(p);                BigInteger se=pre(n.divide(i.multiply(i))).multiply(ff).mod(p);ans=ans.add(fi).subtract(se).mod(p);            &#125;            System.out.println(ans);        &#125;    &#125;&#125;</code></pre><h3 id="对拍代码"><a href="#对拍代码" class="headerlink" title="对拍代码"></a>对拍代码</h3><p>命令为run.sh文件，在命令行中输入<code>run.sh</code> 即可。</p><pre><code class="hljs shell">cnt=0 while true; do./c &gt; data.in                   # c是生成输入样例的程序的二进制文件./a&lt;data.in&gt; a.out              # a是正确程序的二进制文件java Main&lt;data.in&gt; b.out        # 运行java程序生成的二进制文件diff a.out b.out                # 判断两个程序的输出是否相同if [ $? -ne 0 ] ;               # 如果不同的话，就break，那么data.in 中的样例就是出问题的then break;else echo $cnt                   # 如果相同的话，继续下一个对拍循环let cnt=cnt+1         cat data.infidone</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这题前前后后拖了两天，今天总算是把题目和题解整完了：）</p><p>为了解释清楚公式推倒过程，非常详细地叙述了细节，同时提供了大量的参考资料。</p><p>这么写博客真的是很耗费时间啊，以后尽量要注重语言的简练，着重用更少的文字表达出自己的思想。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://nanti.jisuanke.com/t/A1991" target="_blank" rel="noopener">2018沈阳网络赛c题 Convex Hull</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://wenku.baidu.com/view/542961fdba0d4a7302763ad5.html" target="_blank" rel="noopener">贾志鹏 线性筛法与积性函数</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/skywalkert/article/details/50500009" target="_blank" rel="noopener">浅谈一类积性函数的前缀和</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/qkoqhh/article/details/82532516" target="_blank" rel="noopener">2018沈阳网络赛C(莫比乌斯函数+容斥)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9198885.html" target="_blank" rel="noopener">int218的参考资料</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://blog.csdn.net/u010304217/article/details/37728493" target="_blank" rel="noopener">Java中的BigInteger在ACM中的应用</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://www.szdev.com/blog/Hexo/mathjax-config-and-tutorial/" target="_blank" rel="noopener">mathjax配置及语法 </a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>2018网络赛补题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>莫比乌斯函数</tag>
      
      <tag>容斥</tag>
      
      <tag>int128</tag>
      
      <tag>对拍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用西电宿舍的网线连接电脑使用校园网</title>
    <link href="/2020/06/11/%E4%BD%BF%E7%94%A8%E8%A5%BF%E7%94%B5%E5%AE%BF%E8%88%8D%E7%9A%84%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
    <url>/2020/06/11/%E4%BD%BF%E7%94%A8%E8%A5%BF%E7%94%B5%E5%AE%BF%E8%88%8D%E7%9A%84%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%A0%A1%E5%9B%AD%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>众所周知，西电校园网（stu-wlan）每个月会给大家免费放送10G流量。<br>由于宿舍位置偏僻，所以stu-wlan的无线信号并不好，但是如果使用网线连接电脑经过简单的配置就可以连接校园网了。<br>我寻找到了windows和linux两种操作系统下的配置方法。</p><a id="more"></a><h2 id="windows-配置方法"><a href="#windows-配置方法" class="headerlink" title="windows 配置方法"></a>windows 配置方法</h2><p>图形化界面操作就好了<br><a href="https://www.sohu.com/a/337697344_120068225" target="_blank" rel="noopener">链接放送</a></p><h2 id="linux-配置方法"><a href="#linux-配置方法" class="headerlink" title="linux 配置方法"></a>linux 配置方法</h2><p>需要命令行操作哦<br><a href="https://www.jianshu.com/p/f2184badfe54" target="_blank" rel="noopener">linux打开pppoe的方法</a></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>如果可能的话，以后要认真搞搞计网的知识了哦：）</p>]]></content>
    
    
    <categories>
      
      <category>西电生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网线连接校园网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Hexo+GitHub Pages+fluid搭建一个酷炫的博客</title>
    <link href="/2020/06/06/%E5%88%A9%E7%94%A8hexo-githubpages-fluid%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%B7%E7%82%AB%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/06/06/%E5%88%A9%E7%94%A8hexo-githubpages-fluid%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%B7%E7%82%AB%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客可以展示一个准程序员的品味。</p><p>之前看到很多同学搭建了好看的博客感觉非常的馋。</p><a id="more"></a><p>可惜之前因为各种没时间<del>偷懒</del>，所以是利用hexo+github pages+非常简单的博客模版的方案。</p><p>即便如此，也是三分钟热度，没有养成及时更新博客的好习惯。</p><p>之前的博客上面更多的是一些不成体系的acm题目以及心情日记。</p><p>所以要从现在开始养成良好的习惯啊！兄弟们你们说对吗？！</p><p>这篇文章就带领大家从头开始整一个炫酷的博客：）</p><h2 id="前期规划"><a href="#前期规划" class="headerlink" title="前期规划"></a>前期规划</h2><h4 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h4><p>我是在manjaro系统上搞的。</p><p>不过其实在windows系统还是在linux系统感觉搞这些都是大同小异啦。</p><h2 id="具体搭建"><a href="#具体搭建" class="headerlink" title="具体搭建"></a>具体搭建</h2><p>首先基础的步骤按照   <a href="https://www.jianshu.com/p/860d3e0fff58" target="_blank" rel="noopener">Hexo+GithubPages 非常简单易行的搭建个人博客</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Hexo+GithubPages 非常简单易行的搭建个人博客">[1]</span></a></sup> 来走。</p><p>如果按照一般情况 直接走完这个博客的流程 就可以 搞好一个基础的博客了:）</p><p><del>旁白：那我还写这个博客干什么？</del></p><p>我（苦笑）：因为我们总会遇到各种坑啊！！！</p><p>上述的博客内容当中，需要参考的主要是 <strong>搭建个人博客的步骤</strong>中的如下部分：</p><ul><li>GitHhub创建个人仓库</li><li>安装Git</li><li>将本地git与GitHUb账号绑定</li><li>安装node.js</li><li>安装hexo</li><li>把博客的更新部署到GitHub上</li><li>更换主题</li></ul><p>在这里将本地git与Github账号绑定，基本上使用都是在GitHub网站上添加ssh生成的密钥的公钥的方式。</p><p>之后把博客的更新部署到GitHub上利用的<code>hexo d</code>命令背后同样也利用了ssh连接。</p><p>但是由于众所周知的原因，现在GitHub网站慢的一批，这里就需要proxychains的使用了，配置好之后，只需要在相关命令前输入<code>proxychains</code>就好。</p><p>很可惜，即便如此，<code>ssh -T git@github.com</code>还是走不通，所以我把配置文件改为了https的形式，</p><p>具体参考了这一篇博客 <a href="https://blog.csdn.net/qq_40612211/article/details/104278941" target="_blank" rel="noopener">Hexo通过https方式免密部署到github</a> <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Hexo通过https方式免密部署到github">[2]</span></a></sup> 。</p><p>这样我们在浏览器中输入<code>username.github.io</code>，这里的<code>username</code>就是GitHub的用户名，注意更换。</p><p>就可以看到一个博客的基本的状态，非常的朴素。</p><p>所以需要进行主题的更换。</p><p>我选择的是fluid这一款主题，具体的GitHub地址在这里： <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">hexo-theme-fluid</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="hexo-theme-fluid">[3]</span></a></sup>。</p><p>fluid主题不仅绚丽好看，交互设计也设计得很好，同时也提供了详细的文档： <a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="noopener">Fluid的配置指南</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Fluid的配置指南">[4]</span></a></sup>。</p><p>大家可以在具体的文档当中寻找答案，在themes中的配置文件<code>_config.yml</code>中也有非常详细的注释<del>尽管如此修改配置的过程并不轻松</del>。</p><p>对于博客的主题和内容我主要完成了如下几个方面的修改。</p><ul><li>[x] 修改了博客的各种背景图片。</li><li>[x] 添加了一些小伙伴的友情连接。</li><li>[x] 添加了自我介绍（about）的页面。</li></ul><p>下面是代做事项：</p><ul><li>[ ] 把之前的文章整理到新的博客上来。</li><li>[ ] 添加评论功能。</li></ul><p>之后如果想把<code>username.github.io</code>和你所购买的域名绑定的话，可以参考如下的两篇文章：</p><p><a href="https://www.cnblogs.com/yinxiang/p/9237488.html" target="_blank" rel="noopener">利用GitHub搭建Hexo博客并开启HTTPS</a><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="利用GitHub搭建Hexo博客并开启HTTPS">[5]</span></a></sup>,</p><p><a href="https://cloud.tencent.com/developer/article/1421879" target="_blank" rel="noopener">GitHub Pages 搭建的博客绑定域名</a><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="GitHub Pages 搭建的博客绑定域名 ">[6]</span></a></sup>。</p><p>还有一些关于markdown格式的资料，可以参考如下的这篇文章:<br><a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">Markdown语法大全(超级版)</a><sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Markdown语法大全(超级版)">[7]</span></a></sup>。</p><p>以及这是fluid作者开发的markdown在线编辑器，当中有markdown基本语法的展示，所见即所得：<br><a href="https://prod.zkqiang.cn/wxeditor/index.html" target="_blank" rel="noopener">markdown 在线编辑</a><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="markdown 在线编辑">[8]</span></a></sup>。</p><p>到此为止，博客的基本配置就搞完了，虽然说起来并不复杂，但是查阅文档和修改各种配置还是非常费事的，</p><p>特别是修改博客的各种图片，反反复复调试效果，<del>和女同学化妆有异曲同工之妙，</del>博客的搭建和各种配置的调整大约花费了一天的时间。</p><h2 id="关于博客的计划"><a href="#关于博客的计划" class="headerlink" title="关于博客的计划"></a>关于博客的计划</h2><p>当然啦，如果只是搭建博客，其实并没有什么难度。</p><p>困难的地方在于，可以一直保持一个分享的心态，可以常常把自己的所思所想更新在博客上，这对于我的日常生活也起到了一个积累的作用。</p><p>当然啦，写博客最大的一个问题还在于很多时候都是自己一个人写，得到的周围人的反馈很少，所以我会常常把一些文章同时在<code>知乎</code>等平台上发表出来，或者可以转化成视频的形式在B站上发布出来，这样可以起到<code>引流</code>的效果。</p><p>博客也并不希望非常严肃，总之还是希望保持一些年轻人的朝气的，装逼味不应该太重，哈哈哈哈。</p><p>这篇博客就到这里啦，希望大家可以看到这里有一些收获。</p><p>如果按照这篇博客的流程搭建博客依然遇到了问题的话，可以联系我，我如果有时间的话会在能力范围之内提供尽可能的帮助。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/860d3e0fff58" target="_blank" rel="noopener">Hexo+GithubPages 非常简单易行的搭建个人博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_40612211/article/details/104278941" target="_blank" rel="noopener">Hexo通过https方式免密部署到github</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">hexo-theme-fluid</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="noopener">Fluid的配置指南</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cnblogs.com/yinxiang/p/9237488.html" target="_blank" rel="noopener">利用GitHub搭建Hexo博客并开启HTTPS</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1421879" target="_blank" rel="noopener">GitHub Pages 搭建的博客绑定域名</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">Markdown语法大全(超级版)</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://prod.zkqiang.cn/wxeditor/index.html" target="_blank" rel="noopener">markdown 在线编辑</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github pages</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚妄的理想主义者的幸运</title>
    <link href="/2019/09/20/%E8%99%9A%E5%A6%84%E7%9A%84%E7%90%86%E6%83%B3%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E5%B9%B8%E8%BF%90/"/>
    <url>/2019/09/20/%E8%99%9A%E5%A6%84%E7%9A%84%E7%90%86%E6%83%B3%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E5%B9%B8%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<p>2017年新国辩，纯粹的世俗投机者和虚妄的理想主义者哪个更可悲。<br>正方四辩是北京师范大学刘一枫，这是他结辩词中的一部分，很有共鸣。<br>希望大家都可以有自己的理想，即使是一个虚妄的理想。<br><a id="more"></a></p><h2 id="刘一枫的陈词"><a href="#刘一枫的陈词" class="headerlink" title="刘一枫的陈词"></a>刘一枫的陈词</h2><p>同学我和你讲一个我自己的例子好了，我以前是一个非常非常热爱辩论的人，待会儿比赛结束我就会把我的头巾拿下来，因为我退役了，从此以后，热爱辩论的心死了，以前我认为我只要打比赛我就很快乐，但是更快乐的事情是那个时候我不管输不管赢，我都觉得特别充实，为什么呢？因为我当时我内心有这样一个想法，只要我准备的够充分，只要我足够努力，在座各位，我可以赢下你们所有人。我可以赢下所有人，只要我准备得够努力。打完比赛我输了的时候我也不会特别难受，因为我觉得好像是我做得不够好，如果我在场上再努力一点，有一个评委就会给我投票，我再努力一点，也许那个论点，我可以改变它的措辞，如果我再努力一点，我当时就可以想到当时最完美的例子。我以为，我努力就可以解决这一切，但是就像我方前面讲的，后来我发现好像人生不如意十之八九。你有的时候准备得够充分，你发现对手比你准备得更充分，你有的时候发现你准备再长时间，对手的论点都会超出你的射程，你有时候发现自己花了无数个日月，但是你看来了之后，是不是第一场比赛就输了，被淘汰了，人生不如意十之八九。很多时候，这件事情就像一个赌局，你说我付出的精力、我花费的努力、我找到的论点，这就是我在这场比赛中的投入的赌注，我知道它的赔率，但是我永远算不出赔率发生的概率，就是最后的结果我是算不出来的。但是这个时候，对方同学你知道我为什么原来那么幸福吗？那么快乐吗？这就是我方和您讲的，因为得失心没有那么强，因为我觉得我热爱辩论，当我打输比赛，也许最后结果不好，但是我认为我之前所付出的一切，因为我热爱辩论，所以我认为是是值得的。</p>]]></content>
    
    
    <categories>
      
      <category>思辨-读书-看电影</category>
      
      <category>思辨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思辨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的单位换算</title>
    <link href="/2019/08/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97/"/>
    <url>/2019/08/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>方便计算空间<br><a id="more"></a><br>$ 1 MB=1024 KB=1048576 B \approx 1e6 B  $<br>$ 1B = 8 bit $</p><p>//下面的这些是依赖于平台实现的样子<br>//一般64位机是这样实现的</p><p>$ 1 int = 4 Bytes $  //需不需要加s并不确定<br>$ 1 long long = 8 Bytes $</p><div class="table-container"><table><thead><tr><th style="text-align:center">　空间大小 (MB)　</th><th style="text-align:center">　 空间大小(KB) 　</th><th style="text-align:center">　 空间大小(B) 　</th><th style="text-align:center">　int个数　</th><th style="text-align:center">　int个数（约数)　</th></tr></thead><tbody><tr><td style="text-align:center">32</td><td style="text-align:center">32768</td><td style="text-align:center">33554432</td><td style="text-align:center">8388608</td><td style="text-align:center">83.8e5</td></tr><tr><td style="text-align:center">64</td><td style="text-align:center">65536</td><td style="text-align:center">67108864</td><td style="text-align:center">16777216</td><td style="text-align:center">16.7e6</td></tr><tr><td style="text-align:center">128</td><td style="text-align:center">131072</td><td style="text-align:center">134217728</td><td style="text-align:center">33554432</td><td style="text-align:center">33.5e6</td></tr><tr><td style="text-align:center">256</td><td style="text-align:center">262144</td><td style="text-align:center">268435456</td><td style="text-align:center">67108864</td><td style="text-align:center">67.1e6</td></tr></tbody></table></div><p><del>这个表格的渲染让强迫症的我有点难受</del><br><del>等有空再换一个主题吧</del></p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>备用模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lazy标记</title>
    <link href="/2019/04/29/lazy/"/>
    <url>/2019/04/29/lazy/</url>
    
    <content type="html"><![CDATA[<p>线段树模板留存，支持<code>成段增减</code>和<code>区间求和</code>。</p><p>区间整体赋值要加lazy标记。<br>同时探讨了为什么线段树要开4倍空间。</p><a id="more"></a><h2 id="poj3468的代码"><a href="#poj3468的代码" class="headerlink" title="poj3468的代码"></a>poj3468的代码</h2><p>这个是按照胡浩线段树的模板写的<br>添加了一些有助于自己理解的注释<br><pre><code class="hljs c++"><span class="hljs-comment">//update 成段增减</span><span class="hljs-comment">//query 区间求和</span><span class="hljs-comment">//poj3468</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> ch=getchar();<span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) &#123; <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>) f=<span class="hljs-number">-1</span>;ch=getchar();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123; x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;ch=getchar();&#125;<span class="hljs-keyword">return</span> f*x;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> o rt</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls o&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs o&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,ls</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rs</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">111111</span>;ll add[maxn&lt;&lt;<span class="hljs-number">2</span>];ll sum[maxn&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span>&#123;sum[o]=sum[ls]+sum[rs];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o,<span class="hljs-keyword">int</span> m)</span></span>&#123;<span class="hljs-keyword">if</span>(add[o])&#123;add[ls]+=add[o];add[rs]+=add[o];<span class="hljs-comment">//(m-(m&gt;&gt;1))是左孩子的区间长度</span><span class="hljs-comment">//(m&gt;&gt;1)是右孩子的区间长度</span>sum[ls]+=add[o]*(m-(m&gt;&gt;<span class="hljs-number">1</span>));sum[rs]+=add[o]*(m&gt;&gt;<span class="hljs-number">1</span>);add[o]=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;add[rt]=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l==r)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,sum+o);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;build(lson);build(rson);pushup(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;    <span class="hljs-comment">//当[l,r]是属于[ql,qr]时,则更新lazy标记和sum,同时return</span><span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;add[rt]+=c;sum[rt]+=(ll)c*(r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span>;&#125;pushdown(o,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) update(ql,qr,c,lson);<span class="hljs-keyword">if</span>(m&lt;qr) update(ql,qr,c,rson);pushup(o);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> o)</span></span>&#123;<span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) <span class="hljs-keyword">return</span> sum[o];    <span class="hljs-comment">//query 中也可以要用pushdown哦</span>pushdown(rt,r-l+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;ll ret=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql&lt;=m) ret+=query(ql,qr,lson);<span class="hljs-keyword">if</span>(m&lt;qr) ret+=query(ql,qr,rson);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">int</span> q=<span class="hljs-built_in">read</span>();build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span>(q--)&#123;<span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> a,b,c;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,op);<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>)&#123;a=<span class="hljs-built_in">read</span>();b=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,query(a,b,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);update(a,b,c,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><h2 id="四倍空间"><a href="#四倍空间" class="headerlink" title="四倍空间"></a>四倍空间</h2><p>参考资料一的公式打印有问题<br>正确的格式为 <script type="math/tex">2^{log_2n+2}-1</script><br><pre><code class="hljs c++"><span class="hljs-comment">//测试函数c++版</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,a,b) for(int i=a;i&lt;=b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> db double</span><span class="hljs-function">db <span class="hljs-title">op</span><span class="hljs-params">(db x,db y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">log</span>(x)/<span class="hljs-built_in">log</span>(y);&#125;<span class="hljs-function">db <span class="hljs-title">res</span><span class="hljs-params">(db x)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,op(x,<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;inc(i,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)&#123;db x=i;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.3f %.3f\n"</span>,res(i),<span class="hljs-number">4.0</span>*i);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><pre><code class="hljs python"><span class="hljs-comment">#测试函数python版</span><span class="hljs-keyword">import</span> math<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">op</span><span class="hljs-params">(n)</span>:</span>    n=math.log(n,<span class="hljs-number">2</span>)    res=math.pow(<span class="hljs-number">2</span>,n+<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>    <span class="hljs-keyword">return</span> res<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):    print(op(i))    print(<span class="hljs-number">4</span>*i)</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/smoggyxhdz/article/details/78895672" target="_blank" rel="noopener">为什么线段树要开4倍空间</a><br><a href="https://blog.csdn.net/chrome_matrix_68/article/details/52154139" target="_blank" rel="noopener">胡浩线段树</a><br><a href="https://blog.csdn.net/u012469987/article/details/41357377" target="_blank" rel="noopener">lazy标记</a></p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>备用模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>lazy标记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
